"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureApp = configureApp;
exports.default = void 0;
exports.duplicateKeys = duplicateKeys;
exports.generateDriverLogPrefix = generateDriverLogPrefix;
exports.isPackageOrBundle = isPackageOrBundle;
exports.parseCapsArray = parseCapsArray;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _logger = _interopRequireDefault(require("./logger"));

var _support = require("@appium/support");

var _lruCache = _interopRequireDefault(require("lru-cache"));

var _asyncLock = _interopRequireDefault(require("async-lock"));

var _axios = _interopRequireDefault(require("axios"));

const IPA_EXT = '.ipa';
const ZIP_EXTS = ['.zip', IPA_EXT];
const ZIP_MIME_TYPES = ['application/zip', 'application/x-zip-compressed', 'multipart/x-zip'];
const CACHED_APPS_MAX_AGE = 1000 * 60 * 60 * 24;
const MAX_CACHED_APPS = 1024;
const APPLICATIONS_CACHE = new _lruCache.default({
  max: MAX_CACHED_APPS,
  ttl: CACHED_APPS_MAX_AGE,
  updateAgeOnGet: true,
  dispose: (app, {
    fullPath
  }) => {
    _logger.default.info(`The application '${app}' cached at '${fullPath}' has ` + `expired after ${CACHED_APPS_MAX_AGE}ms`);

    if (fullPath) {
      _support.fs.rimraf(fullPath);
    }
  },
  noDisposeOnSet: true
});
const APPLICATIONS_CACHE_GUARD = new _asyncLock.default();
const SANITIZE_REPLACEMENT = '-';
const DEFAULT_BASENAME = 'appium-app';
const APP_DOWNLOAD_TIMEOUT_MS = 120 * 1000;
process.on('exit', () => {
  if (APPLICATIONS_CACHE.size === 0) {
    return;
  }

  const appPaths = [...APPLICATIONS_CACHE.values()].map(({
    fullPath
  }) => fullPath);

  _logger.default.debug(`Performing cleanup of ${appPaths.length} cached ` + _support.util.pluralize('application', appPaths.length));

  for (const appPath of appPaths) {
    try {
      _support.fs.rimrafSync(appPath);
    } catch (e) {
      _logger.default.warn(e.message);
    }
  }
});

async function retrieveHeaders(link) {
  try {
    return (await (0, _axios.default)({
      url: link,
      method: 'HEAD',
      timeout: 5000
    })).headers;
  } catch (e) {
    _logger.default.info(`Cannot send HEAD request to '${link}'. Original error: ${e.message}`);
  }

  return {};
}

function getCachedApplicationPath(link, currentAppProps = {}, cachedAppInfo = {}) {
  const refresh = () => {
    _logger.default.debug(`A fresh copy of the application is going to be downloaded from ${link}`);

    return null;
  };

  if (!_lodash.default.isPlainObject(cachedAppInfo) || !_lodash.default.isPlainObject(currentAppProps)) {
    return refresh();
  }

  const {
    lastModified: currentModified,
    immutable: currentImmutable,
    maxAge: currentMaxAge
  } = currentAppProps;
  const {
    lastModified,
    immutable,
    timestamp,
    fullPath
  } = cachedAppInfo;

  if (lastModified && currentModified) {
    if (currentModified.getTime() <= lastModified.getTime()) {
      _logger.default.debug(`The application at ${link} has not been modified since ${lastModified}`);

      return fullPath;
    }

    _logger.default.debug(`The application at ${link} has been modified since ${lastModified}`);

    return refresh();
  }

  if (immutable && currentImmutable) {
    _logger.default.debug(`The application at ${link} is immutable`);

    return fullPath;
  }

  if (currentMaxAge && timestamp) {
    const msLeft = timestamp + currentMaxAge * 1000 - Date.now();

    if (msLeft > 0) {
      _logger.default.debug(`The cached application '${_path.default.basename(fullPath)}' will expire in ${msLeft / 1000}s`);

      return fullPath;
    }

    _logger.default.debug(`The cached application '${_path.default.basename(fullPath)}' has expired`);
  }

  return refresh();
}

function verifyAppExtension(app, supportedAppExtensions) {
  if (supportedAppExtensions.map(_lodash.default.toLower).includes(_lodash.default.toLower(_path.default.extname(app)))) {
    return app;
  }

  throw new Error(`New app path '${app}' did not have ` + `${_support.util.pluralize('extension', supportedAppExtensions.length, false)}: ` + supportedAppExtensions);
}

async function calculateFolderIntegrity(folderPath) {
  return (await _support.fs.glob('**/*', {
    cwd: folderPath,
    strict: false,
    nosort: true
  })).length;
}

async function calculateFileIntegrity(filePath) {
  return await _support.fs.hash(filePath);
}

async function isAppIntegrityOk(currentPath, expectedIntegrity = {}) {
  if (!(await _support.fs.exists(currentPath))) {
    return false;
  }

  return (await _support.fs.stat(currentPath)).isDirectory() ? (await calculateFolderIntegrity(currentPath)) >= (expectedIntegrity === null || expectedIntegrity === void 0 ? void 0 : expectedIntegrity.folder) : (await calculateFileIntegrity(currentPath)) === (expectedIntegrity === null || expectedIntegrity === void 0 ? void 0 : expectedIntegrity.file);
}

async function configureApp(app, options = {}) {
  if (!_lodash.default.isString(app)) {
    return;
  }

  let supportedAppExtensions;
  const onPostProcess = !_lodash.default.isString(options) && !_lodash.default.isArray(options) ? options.onPostProcess : undefined;

  if (_lodash.default.isString(options)) {
    supportedAppExtensions = [options];
  } else if (_lodash.default.isArray(options)) {
    supportedAppExtensions = options;
  } else if (_lodash.default.isPlainObject(options)) {
    supportedAppExtensions = options.supportedExtensions;
  }

  if (_lodash.default.isEmpty(supportedAppExtensions)) {
    throw new Error(`One or more supported app extensions must be provided`);
  }

  let newApp = app;
  let shouldUnzipApp = false;
  let packageHash = null;
  let headers = null;
  const remoteAppProps = {
    lastModified: null,
    immutable: false,
    maxAge: null
  };

  const {
    protocol,
    pathname
  } = _url.default.parse(newApp);

  const isUrl = protocol === null ? false : ['http:', 'https:'].includes(protocol);
  const cachedAppInfo = APPLICATIONS_CACHE.get(app);
  return await APPLICATIONS_CACHE_GUARD.acquire(app, async () => {
    if (isUrl) {
      _logger.default.info(`Using downloadable app '${newApp}'`);

      headers = await retrieveHeaders(newApp);

      if (!_lodash.default.isEmpty(headers)) {
        if (headers['last-modified']) {
          remoteAppProps.lastModified = new Date(headers['last-modified']);
        }

        _logger.default.debug(`Last-Modified: ${headers['last-modified']}`);

        if (headers['cache-control']) {
          remoteAppProps.immutable = /\bimmutable\b/i.test(headers['cache-control']);
          const maxAgeMatch = /\bmax-age=(\d+)\b/i.exec(headers['cache-control']);

          if (maxAgeMatch) {
            remoteAppProps.maxAge = parseInt(maxAgeMatch[1], 10);
          }
        }

        _logger.default.debug(`Cache-Control: ${headers['cache-control']}`);
      }

      const cachedPath = getCachedApplicationPath(app, remoteAppProps, cachedAppInfo);

      if (cachedPath) {
        if (await isAppIntegrityOk(cachedPath, cachedAppInfo === null || cachedAppInfo === void 0 ? void 0 : cachedAppInfo.integrity)) {
          _logger.default.info(`Reusing previously downloaded application at '${cachedPath}'`);

          return verifyAppExtension(cachedPath, supportedAppExtensions);
        }

        _logger.default.info(`The application at '${cachedPath}' does not exist anymore ` + `or its integrity has been damaged. Deleting it from the internal cache`);

        APPLICATIONS_CACHE.delete(app);
      }

      let fileName = null;

      const basename = _support.fs.sanitizeName(_path.default.basename(decodeURIComponent(pathname !== null && pathname !== void 0 ? pathname : '')), {
        replacement: SANITIZE_REPLACEMENT
      });

      const extname = _path.default.extname(basename);

      if (ZIP_EXTS.includes(extname)) {
        fileName = basename;
        shouldUnzipApp = true;
      }

      if (headers['content-type']) {
        const ct = headers['content-type'];

        _logger.default.debug(`Content-Type: ${ct}`);

        if (ZIP_MIME_TYPES.some(mimeType => new RegExp(`\\b${_lodash.default.escapeRegExp(mimeType)}\\b`).test(ct))) {
          if (!fileName) {
            fileName = `${DEFAULT_BASENAME}.zip`;
          }

          shouldUnzipApp = true;
        }
      }

      if (headers['content-disposition'] && /^attachment/i.test(headers['content-disposition'])) {
        _logger.default.debug(`Content-Disposition: ${headers['content-disposition']}`);

        const match = /filename="([^"]+)/i.exec(headers['content-disposition']);

        if (match) {
          fileName = _support.fs.sanitizeName(match[1], {
            replacement: SANITIZE_REPLACEMENT
          });
          shouldUnzipApp = shouldUnzipApp || ZIP_EXTS.includes(_path.default.extname(fileName));
        }
      }

      if (!fileName) {
        const resultingName = basename ? basename.substring(0, basename.length - extname.length) : DEFAULT_BASENAME;
        let resultingExt = extname;

        if (!supportedAppExtensions.includes(resultingExt)) {
          _logger.default.info(`The current file extension '${resultingExt}' is not supported. ` + `Defaulting to '${_lodash.default.first(supportedAppExtensions)}'`);

          resultingExt = _lodash.default.first(supportedAppExtensions);
        }

        fileName = `${resultingName}${resultingExt}`;
      }

      const targetPath = await _support.tempDir.path({
        prefix: fileName,
        suffix: ''
      });
      newApp = await downloadApp(newApp, targetPath);
    } else if (await _support.fs.exists(newApp)) {
      _logger.default.info(`Using local app '${newApp}'`);

      shouldUnzipApp = ZIP_EXTS.includes(_path.default.extname(newApp));
    } else {
      let errorMessage = `The application at '${newApp}' does not exist or is not accessible`;

      if (_lodash.default.isString(protocol) && protocol.length > 2) {
        errorMessage = `The protocol '${protocol}' used in '${newApp}' is not supported. ` + `Only http: and https: protocols are supported`;
      }

      throw new Error(errorMessage);
    }

    const isPackageAFile = (await _support.fs.stat(newApp)).isFile();

    if (isPackageAFile) {
      packageHash = await calculateFileIntegrity(newApp);
    }

    if (isPackageAFile && shouldUnzipApp && !_lodash.default.isFunction(onPostProcess)) {
      const archivePath = newApp;

      if (packageHash === (cachedAppInfo === null || cachedAppInfo === void 0 ? void 0 : cachedAppInfo.packageHash)) {
        const {
          fullPath
        } = cachedAppInfo;

        if (await isAppIntegrityOk(fullPath, cachedAppInfo === null || cachedAppInfo === void 0 ? void 0 : cachedAppInfo.integrity)) {
          if (archivePath !== app) {
            await _support.fs.rimraf(archivePath);
          }

          _logger.default.info(`Will reuse previously cached application at '${fullPath}'`);

          return verifyAppExtension(fullPath, supportedAppExtensions);
        }

        _logger.default.info(`The application at '${fullPath}' does not exist anymore ` + `or its integrity has been damaged. Deleting it from the cache`);

        APPLICATIONS_CACHE.delete(app);
      }

      const tmpRoot = await _support.tempDir.openDir();

      try {
        newApp = await unzipApp(archivePath, tmpRoot, supportedAppExtensions);
      } finally {
        if (newApp !== archivePath && archivePath !== app) {
          await _support.fs.rimraf(archivePath);
        }
      }

      _logger.default.info(`Unzipped local app to '${newApp}'`);
    } else if (!_path.default.isAbsolute(newApp)) {
      newApp = _path.default.resolve(process.cwd(), newApp);

      _logger.default.warn(`The current application path '${app}' is not absolute ` + `and has been rewritten to '${newApp}'. Consider using absolute paths rather than relative`);

      app = newApp;
    }

    const storeAppInCache = async appPathToCache => {
      const cachedFullPath = cachedAppInfo === null || cachedAppInfo === void 0 ? void 0 : cachedAppInfo.fullPath;

      if (cachedFullPath && cachedFullPath !== appPathToCache) {
        await _support.fs.rimraf(cachedFullPath);
      }

      const integrity = {};

      if ((await _support.fs.stat(appPathToCache)).isDirectory()) {
        integrity.folder = await calculateFolderIntegrity(appPathToCache);
      } else {
        integrity.file = await calculateFileIntegrity(appPathToCache);
      }

      APPLICATIONS_CACHE.set(app, { ...remoteAppProps,
        timestamp: Date.now(),
        packageHash,
        integrity,
        fullPath: appPathToCache
      });
      return appPathToCache;
    };

    if (_lodash.default.isFunction(onPostProcess)) {
      const result = await onPostProcess({
        cachedAppInfo: _lodash.default.clone(cachedAppInfo),
        isUrl,
        headers: _lodash.default.clone(headers),
        appPath: newApp
      });
      return !(result !== null && result !== void 0 && result.appPath) || app === (result === null || result === void 0 ? void 0 : result.appPath) || !(await _support.fs.exists(result === null || result === void 0 ? void 0 : result.appPath)) ? newApp : await storeAppInCache(result.appPath);
    }

    verifyAppExtension(newApp, supportedAppExtensions);
    return app !== newApp && (packageHash || _lodash.default.values(remoteAppProps).some(Boolean)) ? await storeAppInCache(newApp) : newApp;
  });
}

async function downloadApp(app, targetPath) {
  const {
    href
  } = _url.default.parse(app);

  try {
    await _support.net.downloadFile(href, targetPath, {
      timeout: APP_DOWNLOAD_TIMEOUT_MS
    });
  } catch (err) {
    throw new Error(`Unable to download the app: ${err.message}`);
  }

  return targetPath;
}

async function unzipApp(zipPath, dstRoot, supportedAppExtensions) {
  await _support.zip.assertValidZip(zipPath);

  if (!_lodash.default.isArray(supportedAppExtensions)) {
    supportedAppExtensions = [supportedAppExtensions];
  }

  const tmpRoot = await _support.tempDir.openDir();

  try {
    _logger.default.debug(`Unzipping '${zipPath}'`);

    const timer = new _support.timing.Timer().start();
    const useSystemUnzipEnv = process.env.APPIUM_PREFER_SYSTEM_UNZIP;
    const useSystemUnzip = _lodash.default.isEmpty(useSystemUnzipEnv) || !['0', 'false'].includes(_lodash.default.toLower(useSystemUnzipEnv));
    const extractionOpts = {
      useSystemUnzip
    };

    if (_path.default.extname(zipPath) === IPA_EXT) {
      _logger.default.debug(`Enforcing UTF-8 encoding on the extracted file names for '${_path.default.basename(zipPath)}'`);

      extractionOpts.fileNamesEncoding = 'utf8';
    }

    await _support.zip.extractAllTo(zipPath, tmpRoot, extractionOpts);
    const globPattern = `**/*.+(${supportedAppExtensions.map(ext => ext.replace(/^\./, '')).join('|')})`;
    const sortedBundleItems = (await _support.fs.glob(globPattern, {
      cwd: tmpRoot,
      strict: false
    })).sort((a, b) => a.split(_path.default.sep).length - b.split(_path.default.sep).length);

    if (_lodash.default.isEmpty(sortedBundleItems)) {
      _logger.default.errorAndThrow(`App unzipped OK, but we could not find any '${supportedAppExtensions}' ` + _support.util.pluralize('bundle', supportedAppExtensions.length, false) + ` in it. Make sure your archive contains at least one package having ` + `'${supportedAppExtensions}' ${_support.util.pluralize('extension', supportedAppExtensions.length, false)}`);
    }

    _logger.default.debug(`Extracted ${_support.util.pluralize('bundle item', sortedBundleItems.length, true)} ` + `from '${zipPath}' in ${Math.round(timer.getDuration().asMilliSeconds)}ms: ${sortedBundleItems}`);

    const matchedBundle = _lodash.default.first(sortedBundleItems);

    _logger.default.info(`Assuming '${matchedBundle}' is the correct bundle`);

    const dstPath = _path.default.resolve(dstRoot, _path.default.basename(matchedBundle));

    await _support.fs.mv(_path.default.resolve(tmpRoot, matchedBundle), dstPath, {
      mkdirp: true
    });
    return dstPath;
  } finally {
    await _support.fs.rimraf(tmpRoot);
  }
}

function isPackageOrBundle(app) {
  return /^([a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)+$/.test(app);
}

function duplicateKeys(input, firstKey, secondKey) {
  if (_lodash.default.isArray(input)) {
    return input.map(item => duplicateKeys(item, firstKey, secondKey));
  }

  if (_lodash.default.isPlainObject(input)) {
    const resultObj = {};

    for (let [key, value] of _lodash.default.toPairs(input)) {
      const recursivelyCalledValue = duplicateKeys(value, firstKey, secondKey);

      if (key === firstKey) {
        resultObj[secondKey] = recursivelyCalledValue;
      } else if (key === secondKey) {
        resultObj[firstKey] = recursivelyCalledValue;
      }

      resultObj[key] = recursivelyCalledValue;
    }

    return resultObj;
  }

  return input;
}

function parseCapsArray(cap) {
  if (_lodash.default.isArray(cap)) {
    return cap;
  }

  let parsedCaps;

  try {
    parsedCaps = JSON.parse(cap);

    if (_lodash.default.isArray(parsedCaps)) {
      return parsedCaps;
    }
  } catch (ign) {
    _logger.default.warn(`Failed to parse capability as JSON array`);
  }

  if (_lodash.default.isString(cap)) {
    return [cap];
  }

  throw new Error(`must provide a string or JSON Array; received ${cap}`);
}

function generateDriverLogPrefix(obj, sessionId = null) {
  const instanceName = `${obj.constructor.name}@${_support.node.getObjectId(obj).substring(0, 4)}`;
  return sessionId ? `${instanceName} (${sessionId.substring(0, 8)})` : instanceName;
}

var _default = {
  configureApp,
  isPackageOrBundle,
  duplicateKeys,
  parseCapsArray,
  generateDriverLogPrefix
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJJUEFfRVhUIiwiWklQX0VYVFMiLCJaSVBfTUlNRV9UWVBFUyIsIkNBQ0hFRF9BUFBTX01BWF9BR0UiLCJNQVhfQ0FDSEVEX0FQUFMiLCJBUFBMSUNBVElPTlNfQ0FDSEUiLCJMUlUiLCJtYXgiLCJ0dGwiLCJ1cGRhdGVBZ2VPbkdldCIsImRpc3Bvc2UiLCJhcHAiLCJmdWxsUGF0aCIsImxvZ2dlciIsImluZm8iLCJmcyIsInJpbXJhZiIsIm5vRGlzcG9zZU9uU2V0IiwiQVBQTElDQVRJT05TX0NBQ0hFX0dVQVJEIiwiQXN5bmNMb2NrIiwiU0FOSVRJWkVfUkVQTEFDRU1FTlQiLCJERUZBVUxUX0JBU0VOQU1FIiwiQVBQX0RPV05MT0FEX1RJTUVPVVRfTVMiLCJwcm9jZXNzIiwib24iLCJzaXplIiwiYXBwUGF0aHMiLCJ2YWx1ZXMiLCJtYXAiLCJkZWJ1ZyIsImxlbmd0aCIsInV0aWwiLCJwbHVyYWxpemUiLCJhcHBQYXRoIiwicmltcmFmU3luYyIsImUiLCJ3YXJuIiwibWVzc2FnZSIsInJldHJpZXZlSGVhZGVycyIsImxpbmsiLCJheGlvcyIsInVybCIsIm1ldGhvZCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiZ2V0Q2FjaGVkQXBwbGljYXRpb25QYXRoIiwiY3VycmVudEFwcFByb3BzIiwiY2FjaGVkQXBwSW5mbyIsInJlZnJlc2giLCJfIiwiaXNQbGFpbk9iamVjdCIsImxhc3RNb2RpZmllZCIsImN1cnJlbnRNb2RpZmllZCIsImltbXV0YWJsZSIsImN1cnJlbnRJbW11dGFibGUiLCJtYXhBZ2UiLCJjdXJyZW50TWF4QWdlIiwidGltZXN0YW1wIiwiZ2V0VGltZSIsIm1zTGVmdCIsIkRhdGUiLCJub3ciLCJwYXRoIiwiYmFzZW5hbWUiLCJ2ZXJpZnlBcHBFeHRlbnNpb24iLCJzdXBwb3J0ZWRBcHBFeHRlbnNpb25zIiwidG9Mb3dlciIsImluY2x1ZGVzIiwiZXh0bmFtZSIsIkVycm9yIiwiY2FsY3VsYXRlRm9sZGVySW50ZWdyaXR5IiwiZm9sZGVyUGF0aCIsImdsb2IiLCJjd2QiLCJzdHJpY3QiLCJub3NvcnQiLCJjYWxjdWxhdGVGaWxlSW50ZWdyaXR5IiwiZmlsZVBhdGgiLCJoYXNoIiwiaXNBcHBJbnRlZ3JpdHlPayIsImN1cnJlbnRQYXRoIiwiZXhwZWN0ZWRJbnRlZ3JpdHkiLCJleGlzdHMiLCJzdGF0IiwiaXNEaXJlY3RvcnkiLCJmb2xkZXIiLCJmaWxlIiwiY29uZmlndXJlQXBwIiwib3B0aW9ucyIsImlzU3RyaW5nIiwib25Qb3N0UHJvY2VzcyIsImlzQXJyYXkiLCJ1bmRlZmluZWQiLCJzdXBwb3J0ZWRFeHRlbnNpb25zIiwiaXNFbXB0eSIsIm5ld0FwcCIsInNob3VsZFVuemlwQXBwIiwicGFja2FnZUhhc2giLCJyZW1vdGVBcHBQcm9wcyIsInByb3RvY29sIiwicGF0aG5hbWUiLCJwYXJzZSIsImlzVXJsIiwiZ2V0IiwiYWNxdWlyZSIsInRlc3QiLCJtYXhBZ2VNYXRjaCIsImV4ZWMiLCJwYXJzZUludCIsImNhY2hlZFBhdGgiLCJpbnRlZ3JpdHkiLCJkZWxldGUiLCJmaWxlTmFtZSIsInNhbml0aXplTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2VtZW50IiwiY3QiLCJzb21lIiwibWltZVR5cGUiLCJSZWdFeHAiLCJlc2NhcGVSZWdFeHAiLCJtYXRjaCIsInJlc3VsdGluZ05hbWUiLCJzdWJzdHJpbmciLCJyZXN1bHRpbmdFeHQiLCJmaXJzdCIsInRhcmdldFBhdGgiLCJ0ZW1wRGlyIiwicHJlZml4Iiwic3VmZml4IiwiZG93bmxvYWRBcHAiLCJlcnJvck1lc3NhZ2UiLCJpc1BhY2thZ2VBRmlsZSIsImlzRmlsZSIsImlzRnVuY3Rpb24iLCJhcmNoaXZlUGF0aCIsInRtcFJvb3QiLCJvcGVuRGlyIiwidW56aXBBcHAiLCJpc0Fic29sdXRlIiwicmVzb2x2ZSIsInN0b3JlQXBwSW5DYWNoZSIsImFwcFBhdGhUb0NhY2hlIiwiY2FjaGVkRnVsbFBhdGgiLCJzZXQiLCJyZXN1bHQiLCJjbG9uZSIsIkJvb2xlYW4iLCJocmVmIiwibmV0IiwiZG93bmxvYWRGaWxlIiwiZXJyIiwiemlwUGF0aCIsImRzdFJvb3QiLCJ6aXAiLCJhc3NlcnRWYWxpZFppcCIsInRpbWVyIiwidGltaW5nIiwiVGltZXIiLCJzdGFydCIsInVzZVN5c3RlbVVuemlwRW52IiwiZW52IiwiQVBQSVVNX1BSRUZFUl9TWVNURU1fVU5aSVAiLCJ1c2VTeXN0ZW1VbnppcCIsImV4dHJhY3Rpb25PcHRzIiwiZmlsZU5hbWVzRW5jb2RpbmciLCJleHRyYWN0QWxsVG8iLCJnbG9iUGF0dGVybiIsImV4dCIsInJlcGxhY2UiLCJqb2luIiwic29ydGVkQnVuZGxlSXRlbXMiLCJzb3J0IiwiYSIsImIiLCJzcGxpdCIsInNlcCIsImVycm9yQW5kVGhyb3ciLCJNYXRoIiwicm91bmQiLCJnZXREdXJhdGlvbiIsImFzTWlsbGlTZWNvbmRzIiwibWF0Y2hlZEJ1bmRsZSIsImRzdFBhdGgiLCJtdiIsIm1rZGlycCIsImlzUGFja2FnZU9yQnVuZGxlIiwiZHVwbGljYXRlS2V5cyIsImlucHV0IiwiZmlyc3RLZXkiLCJzZWNvbmRLZXkiLCJpdGVtIiwicmVzdWx0T2JqIiwia2V5IiwidmFsdWUiLCJ0b1BhaXJzIiwicmVjdXJzaXZlbHlDYWxsZWRWYWx1ZSIsInBhcnNlQ2Fwc0FycmF5IiwiY2FwIiwicGFyc2VkQ2FwcyIsIkpTT04iLCJpZ24iLCJnZW5lcmF0ZURyaXZlckxvZ1ByZWZpeCIsIm9iaiIsInNlc3Npb25JZCIsImluc3RhbmNlTmFtZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm5vZGUiLCJnZXRPYmplY3RJZCJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9iYXNlZHJpdmVyL2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQge3RlbXBEaXIsIGZzLCB1dGlsLCB6aXAsIG5ldCwgdGltaW5nLCBub2RlfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IEFzeW5jTG9jayBmcm9tICdhc3luYy1sb2NrJztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5cbmNvbnN0IElQQV9FWFQgPSAnLmlwYSc7XG5jb25zdCBaSVBfRVhUUyA9IFsnLnppcCcsIElQQV9FWFRdO1xuY29uc3QgWklQX01JTUVfVFlQRVMgPSBbJ2FwcGxpY2F0aW9uL3ppcCcsICdhcHBsaWNhdGlvbi94LXppcC1jb21wcmVzc2VkJywgJ211bHRpcGFydC94LXppcCddO1xuY29uc3QgQ0FDSEVEX0FQUFNfTUFYX0FHRSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7IC8vIG1zXG5jb25zdCBNQVhfQ0FDSEVEX0FQUFMgPSAxMDI0O1xuY29uc3QgQVBQTElDQVRJT05TX0NBQ0hFID0gbmV3IExSVSh7XG4gIG1heDogTUFYX0NBQ0hFRF9BUFBTLFxuICB0dGw6IENBQ0hFRF9BUFBTX01BWF9BR0UsIC8vIGV4cGlyZSBhZnRlciAyNCBob3Vyc1xuICB1cGRhdGVBZ2VPbkdldDogdHJ1ZSxcbiAgZGlzcG9zZTogKGFwcCwge2Z1bGxQYXRofSkgPT4ge1xuICAgIGxvZ2dlci5pbmZvKFxuICAgICAgYFRoZSBhcHBsaWNhdGlvbiAnJHthcHB9JyBjYWNoZWQgYXQgJyR7ZnVsbFBhdGh9JyBoYXMgYCArXG4gICAgICAgIGBleHBpcmVkIGFmdGVyICR7Q0FDSEVEX0FQUFNfTUFYX0FHRX1tc2BcbiAgICApO1xuICAgIGlmIChmdWxsUGF0aCkge1xuICAgICAgZnMucmltcmFmKGZ1bGxQYXRoKTtcbiAgICB9XG4gIH0sXG4gIG5vRGlzcG9zZU9uU2V0OiB0cnVlLFxufSk7XG5jb25zdCBBUFBMSUNBVElPTlNfQ0FDSEVfR1VBUkQgPSBuZXcgQXN5bmNMb2NrKCk7XG5jb25zdCBTQU5JVElaRV9SRVBMQUNFTUVOVCA9ICctJztcbmNvbnN0IERFRkFVTFRfQkFTRU5BTUUgPSAnYXBwaXVtLWFwcCc7XG5jb25zdCBBUFBfRE9XTkxPQURfVElNRU9VVF9NUyA9IDEyMCAqIDEwMDA7XG5cbnByb2Nlc3Mub24oJ2V4aXQnLCAoKSA9PiB7XG4gIGlmIChBUFBMSUNBVElPTlNfQ0FDSEUuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFwcFBhdGhzID0gWy4uLkFQUExJQ0FUSU9OU19DQUNIRS52YWx1ZXMoKV0ubWFwKCh7ZnVsbFBhdGh9KSA9PiBmdWxsUGF0aCk7XG4gIGxvZ2dlci5kZWJ1ZyhcbiAgICBgUGVyZm9ybWluZyBjbGVhbnVwIG9mICR7YXBwUGF0aHMubGVuZ3RofSBjYWNoZWQgYCArXG4gICAgICB1dGlsLnBsdXJhbGl6ZSgnYXBwbGljYXRpb24nLCBhcHBQYXRocy5sZW5ndGgpXG4gICk7XG4gIGZvciAoY29uc3QgYXBwUGF0aCBvZiBhcHBQYXRocykge1xuICAgIHRyeSB7XG4gICAgICAvLyBBc3luY2hyb25vdXMgY2FsbHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gb25FeGl0IGhhbmRsZXJcbiAgICAgIGZzLnJpbXJhZlN5bmMoYXBwUGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5hc3luYyBmdW5jdGlvbiByZXRyaWV2ZUhlYWRlcnMobGluaykge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICBhd2FpdCBheGlvcyh7XG4gICAgICAgIHVybDogbGluayxcbiAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICB9KVxuICAgICkuaGVhZGVycztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci5pbmZvKGBDYW5ub3Qgc2VuZCBIRUFEIHJlcXVlc3QgdG8gJyR7bGlua30nLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZWRBcHBsaWNhdGlvblBhdGgobGluaywgY3VycmVudEFwcFByb3BzID0ge30sIGNhY2hlZEFwcEluZm8gPSB7fSkge1xuICBjb25zdCByZWZyZXNoID0gKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhgQSBmcmVzaCBjb3B5IG9mIHRoZSBhcHBsaWNhdGlvbiBpcyBnb2luZyB0byBiZSBkb3dubG9hZGVkIGZyb20gJHtsaW5rfWApO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGlmICghXy5pc1BsYWluT2JqZWN0KGNhY2hlZEFwcEluZm8pIHx8ICFfLmlzUGxhaW5PYmplY3QoY3VycmVudEFwcFByb3BzKSkge1xuICAgIC8vIGlmIGFuIGludmFsaWQgYXJnIGlzIHBhc3NlZCB0aGVuIGFzc3VtZSBjYWNoZSBtaXNzXG4gICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBsYXN0TW9kaWZpZWQ6IGN1cnJlbnRNb2RpZmllZCxcbiAgICBpbW11dGFibGU6IGN1cnJlbnRJbW11dGFibGUsXG4gICAgLy8gbWF4QWdlIGlzIGluIHNlY29uZHNcbiAgICBtYXhBZ2U6IGN1cnJlbnRNYXhBZ2UsXG4gIH0gPSBjdXJyZW50QXBwUHJvcHM7XG4gIGNvbnN0IHtcbiAgICAvLyBEYXRlIGluc3RhbmNlXG4gICAgbGFzdE1vZGlmaWVkLFxuICAgIC8vIGJvb2xlYW5cbiAgICBpbW11dGFibGUsXG4gICAgLy8gVW5peCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgIHRpbWVzdGFtcCxcbiAgICBmdWxsUGF0aCxcbiAgfSA9IGNhY2hlZEFwcEluZm87XG4gIGlmIChsYXN0TW9kaWZpZWQgJiYgY3VycmVudE1vZGlmaWVkKSB7XG4gICAgaWYgKGN1cnJlbnRNb2RpZmllZC5nZXRUaW1lKCkgPD0gbGFzdE1vZGlmaWVkLmdldFRpbWUoKSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBUaGUgYXBwbGljYXRpb24gYXQgJHtsaW5rfSBoYXMgbm90IGJlZW4gbW9kaWZpZWQgc2luY2UgJHtsYXN0TW9kaWZpZWR9YCk7XG4gICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgfVxuICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIGFwcGxpY2F0aW9uIGF0ICR7bGlua30gaGFzIGJlZW4gbW9kaWZpZWQgc2luY2UgJHtsYXN0TW9kaWZpZWR9YCk7XG4gICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgfVxuICBpZiAoaW1tdXRhYmxlICYmIGN1cnJlbnRJbW11dGFibGUpIHtcbiAgICBsb2dnZXIuZGVidWcoYFRoZSBhcHBsaWNhdGlvbiBhdCAke2xpbmt9IGlzIGltbXV0YWJsZWApO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuICBpZiAoY3VycmVudE1heEFnZSAmJiB0aW1lc3RhbXApIHtcbiAgICBjb25zdCBtc0xlZnQgPSB0aW1lc3RhbXAgKyBjdXJyZW50TWF4QWdlICogMTAwMCAtIERhdGUubm93KCk7XG4gICAgaWYgKG1zTGVmdCA+IDApIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYFRoZSBjYWNoZWQgYXBwbGljYXRpb24gJyR7cGF0aC5iYXNlbmFtZShmdWxsUGF0aCl9JyB3aWxsIGV4cGlyZSBpbiAke21zTGVmdCAvIDEwMDB9c2BcbiAgICAgICk7XG4gICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgfVxuICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIGNhY2hlZCBhcHBsaWNhdGlvbiAnJHtwYXRoLmJhc2VuYW1lKGZ1bGxQYXRoKX0nIGhhcyBleHBpcmVkYCk7XG4gIH1cbiAgcmV0dXJuIHJlZnJlc2goKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5QXBwRXh0ZW5zaW9uKGFwcCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucykge1xuICBpZiAoc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucy5tYXAoXy50b0xvd2VyKS5pbmNsdWRlcyhfLnRvTG93ZXIocGF0aC5leHRuYW1lKGFwcCkpKSkge1xuICAgIHJldHVybiBhcHA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBOZXcgYXBwIHBhdGggJyR7YXBwfScgZGlkIG5vdCBoYXZlIGAgK1xuICAgICAgYCR7dXRpbC5wbHVyYWxpemUoJ2V4dGVuc2lvbicsIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMubGVuZ3RoLCBmYWxzZSl9OiBgICtcbiAgICAgIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnNcbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlRm9sZGVySW50ZWdyaXR5KGZvbGRlclBhdGgpIHtcbiAgcmV0dXJuIChhd2FpdCBmcy5nbG9iKCcqKi8qJywge2N3ZDogZm9sZGVyUGF0aCwgc3RyaWN0OiBmYWxzZSwgbm9zb3J0OiB0cnVlfSkpLmxlbmd0aDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlRmlsZUludGVncml0eShmaWxlUGF0aCkge1xuICByZXR1cm4gYXdhaXQgZnMuaGFzaChmaWxlUGF0aCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzQXBwSW50ZWdyaXR5T2soY3VycmVudFBhdGgsIGV4cGVjdGVkSW50ZWdyaXR5ID0ge30pIHtcbiAgaWYgKCEoYXdhaXQgZnMuZXhpc3RzKGN1cnJlbnRQYXRoKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGb2xkZXIgaW50ZWdyaXR5IGNoZWNrIGlzIHNpbXBsZTpcbiAgLy8gVmVyaWZ5IHRoZSBwcmV2aW91cyBhbW91bnQgb2YgZmlsZXMgaXMgbm90IGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBvbmUuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gdXNlIGVxdWFsaXR5IGNvbXBhcmlzb24gYmVjYXVzZSBvZiBhbiBhc3N1bXB0aW9uIHRoYXQgdGhlIE9TIG1pZ2h0XG4gIC8vIGNyZWF0ZSBzb21lIHVud2FudGVkIHNlcnZpY2UgZmlsZXMvY2FjaGVkIGluc2lkZSBvZiB0aGF0IGZvbGRlciBvciBpdHMgc3ViZm9sZGVycy5cbiAgLy8gT2ZjLCB2YWxpZGF0aW5nIHRoZSBoYXNoIHN1bSBvZiBlYWNoIGZpbGUgKG9yIGF0IGxlYXN0IG9mIGZpbGUgcGF0aCkgd291bGQgYmUgbXVjaFxuICAvLyBtb3JlIHByZWNpc2UsIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIGJlIHZlcnkgcHJlY2lzZSBoZXJlIGFuZCBhbHNvIGRvbid0IHdhbnQgdG9cbiAgLy8gb3ZlcnVzZSBSQU0gYW5kIGhhdmUgYSBwZXJmb3JtYW5jZSBkcm9wLlxuICByZXR1cm4gKGF3YWl0IGZzLnN0YXQoY3VycmVudFBhdGgpKS5pc0RpcmVjdG9yeSgpXG4gICAgPyAoYXdhaXQgY2FsY3VsYXRlRm9sZGVySW50ZWdyaXR5KGN1cnJlbnRQYXRoKSkgPj0gZXhwZWN0ZWRJbnRlZ3JpdHk/LmZvbGRlclxuICAgIDogKGF3YWl0IGNhbGN1bGF0ZUZpbGVJbnRlZ3JpdHkoY3VycmVudFBhdGgpKSA9PT0gZXhwZWN0ZWRJbnRlZ3JpdHk/LmZpbGU7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUG9zdFByb2Nlc3NPcHRpb25zXG4gKiBAcHJvcGVydHkgez9PYmplY3R9IGNhY2hlZEFwcEluZm8gVGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwcmV2aW91c2x5IGNhY2hlZCBhcHAgaW5zdGFuY2UgKGlmIGV4aXN0cyk6XG4gKiAgICAtIHBhY2thZ2VIYXNoOiBTSEExIGhhc2ggb2YgdGhlIHBhY2thZ2UgaWYgaXQgaXMgYSBmaWxlIGFuZCBub3QgYSBmb2xkZXJcbiAqICAgIC0gbGFzdE1vZGlmaWVkOiBPcHRpb25hbCBEYXRlIGluc3RhbmNlLCB0aGUgdmFsdWUgb2YgZmlsZSdzIGBMYXN0LU1vZGlmaWVkYCBoZWFkZXJcbiAqICAgIC0gaW1tdXRhYmxlOiBPcHRpb25hbCBib29sZWFuIHZhbHVlLiBDb250YWlucyB0cnVlIGlmIHRoZSBmaWxlIGhhcyBhbiBgaW1tdXRhYmxlYCBtYXJrXG4gKiAgICAgICAgICAgICAgICAgaW4gYENhY2hlLWNvbnRyb2xgIGhlYWRlclxuICogICAgLSBtYXhBZ2U6IE9wdGlvbmFsIGludGVnZXIgcmVwcmVzZW50YXRpb24gb2YgYG1heEFnZWAgcGFyYW1ldGVyIGluIGBDYWNoZS1jb250cm9sYCBoZWFkZXJcbiAqICAgIC0gdGltZXN0YW1wOiBUaGUgdGltZXN0YW1wIHRoaXMgaXRlbSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgY2FjaGUgKG1lYXN1cmVkIGluIFVuaXggZXBvY2hcbiAqICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMpXG4gKiAgICAtIGludGVncml0eTogQW4gb2JqZWN0IGNvbnRhaW5pbmcgZWl0aGVyIGBmaWxlYCBwcm9wZXJ0eSB3aXRoIFNIQTEgaGFzaCBvZiB0aGUgZmlsZVxuICogICAgICAgICAgICAgICAgIG9yIGBmb2xkZXJgIHByb3BlcnR5IHdpdGggdG90YWwgYW1vdW50IG9mIGNhY2hlZCBmaWxlcyBhbmQgc3ViZm9sZGVyc1xuICogICAgLSBmdWxsUGF0aDogdGhlIGZ1bGwgcGF0aCB0byB0aGUgY2FjaGVkIGFwcFxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1VybCBXaGV0aGVyIHRoZSBhcHAgaGFzIGJlZW4gZG93bmxvYWRlZCBmcm9tIGEgcmVtb3RlIFVSTFxuICogQHByb3BlcnR5IHs/T2JqZWN0fSBoZWFkZXJzIE9wdGlvbmFsIGhlYWRlcnMgb2JqZWN0LiBPbmx5IHByZXNlbnQgaWYgYGlzVXJsYCBpcyB0cnVlIGFuZCBpZiB0aGUgc2VydmVyXG4gKiByZXNwb25kcyB0byBIRUFEIHJlcXVlc3RzLiBBbGwgaGVhZGVyIG5hbWVzIGFyZSBub3JtYWxpemVkIHRvIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhcHBQYXRoIEEgc3RyaW5nIGNvbnRhaW5pbmcgZnVsbCBwYXRoIHRvIHRoZSBwcmVwcm9jZXNzZWQgYXBwbGljYXRpb24gcGFja2FnZSAoZWl0aGVyXG4gKiBkb3dubG9hZGVkIG9yIGEgbG9jYWwgb25lKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgUG9zdFByb2Nlc3NSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhcHBQYXRoIFRoZSBmdWxsIHBhc3QgdG8gdGhlIHBvc3QtcHJvY2Vzc2VkIGFwcGxpY2F0aW9uIHBhY2thZ2Ugb24gdGhlXG4gKiBsb2NhbCBmaWxlIHN5c3RlbSAobWlnaHQgYmUgYSBmaWxlIG9yIGEgZm9sZGVyIHBhdGgpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBDb25maWd1cmVBcHBPcHRpb25zXG4gKiBAcHJvcGVydHkgeyhvYmo6IFBvc3RQcm9jZXNzT3B0aW9ucykgPT4gKFByb21pc2U8UG9zdFByb2Nlc3NSZXN1bHR8dW5kZWZpbmVkPnxQb3N0UHJvY2Vzc1Jlc3VsdHx1bmRlZmluZWQpfSBbb25Qb3N0UHJvY2Vzc11cbiAqIE9wdGlvbmFsIGZ1bmN0aW9uLCB3aGljaCBzaG91bGQgYmUgYXBwbGllZFxuICogdG8gdGhlIGFwcGxpY2F0aW9uIGFmdGVyIGl0IGlzIGRvd25sb2FkZWQvcHJlcHJvY2Vzc2VkLiBUaGlzIGZ1bmN0aW9uIG1heSBiZSBhc3luY1xuICogYW5kIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBzaW5nbGUgb2JqZWN0IHBhcmFtZXRlci5cbiAqIFRoZSBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byBlaXRoZXIgcmV0dXJuIGEgZmFsc3kgdmFsdWUsIHdoaWNoIG1lYW5zIHRoZSBhcHAgbXVzdCBub3QgYmVcbiAqIGNhY2hlZCBhbmQgYSBmcmVzaCBjb3B5IG9mIGl0IGlzIGRvd25sb2FkZWQgZWFjaCB0aW1lLiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0XG4gKiBjb250YWluaW5nIGBhcHBQYXRoYCBwcm9wZXJ0eSB0aGVuIHRoZSBpbnRlZ3JpdHkgb2YgaXQgd2lsbCBiZSB2ZXJpZmllZCBhbmQgc3RvcmVkIGludG9cbiAqIHRoZSBjYWNoZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHN1cHBvcnRlZEV4dGVuc2lvbnMgTGlzdCBvZiBzdXBwb3J0ZWQgYXBwbGljYXRpb24gZXh0ZW5zaW9ucyAoXG4gKiBpbmNsdWRpbmcgc3RhcnRpbmcgZG90cykuIFRoaXMgcHJvcGVydHkgaXMgbWFuZGF0b3J5IGFuZCBtdXN0IG5vdCBiZSBlbXB0eS5cbiAqL1xuXG4vKipcbiAqIFByZXBhcmVzIGFuIGFwcCB0byBiZSB1c2VkIGluIGFuIGF1dG9tYXRlZCB0ZXN0LiBUaGUgYXBwIGdldHMgY2FjaGVkIGF1dG9tYXRpY2FsbHlcbiAqIGlmIGl0IGlzIGFuIGFyY2hpdmUgb3IgaWYgaXQgaXMgZG93bmxvYWRlZCBmcm9tIGFuIFVSTC5cbiAqIElmIHRoZSBkb3dubG9hZGVkIGFwcCBoYXMgYC56aXBgIGV4dGVuc2lvbiwgdGhpcyBtZXRob2Qgd2lsbCB1bnppcCBpdC5cbiAqIFRoZSB1bnppcCBkb2VzIG5vdCB3b3JrIHdoZW4gYG9uUG9zdFByb2Nlc3NgIGlzIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHAgRWl0aGVyIGEgZnVsbCBwYXRoIHRvIHRoZSBhcHAgb3IgYSByZW1vdGUgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxDb25maWd1cmVBcHBPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZnVsbCBwYXRoIHRvIHRoZSByZXN1bHRpbmcgYXBwbGljYXRpb24gYnVuZGxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbmZpZ3VyZUFwcChhcHAsIG9wdGlvbnMgPSAvKiogQHR5cGUge0NvbmZpZ3VyZUFwcE9wdGlvbnN9ICovICh7fSkpIHtcbiAgaWYgKCFfLmlzU3RyaW5nKGFwcCkpIHtcbiAgICAvLyBpbW1lZGlhdGVseSBzaG9ydGNpcmN1aXQgaWYgbm90IGdpdmVuIGFuIGFwcFxuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zO1xuICBjb25zdCBvblBvc3RQcm9jZXNzID1cbiAgICAhXy5pc1N0cmluZyhvcHRpb25zKSAmJiAhXy5pc0FycmF5KG9wdGlvbnMpID8gb3B0aW9ucy5vblBvc3RQcm9jZXNzIDogdW5kZWZpbmVkO1xuXG4gIGlmIChfLmlzU3RyaW5nKG9wdGlvbnMpKSB7XG4gICAgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyA9IFtvcHRpb25zXTtcbiAgfSBlbHNlIGlmIChfLmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zID0gb3B0aW9ucy5zdXBwb3J0ZWRFeHRlbnNpb25zO1xuICB9XG4gIGlmIChfLmlzRW1wdHkoc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE9uZSBvciBtb3JlIHN1cHBvcnRlZCBhcHAgZXh0ZW5zaW9ucyBtdXN0IGJlIHByb3ZpZGVkYCk7XG4gIH1cblxuICBsZXQgbmV3QXBwID0gYXBwO1xuICBsZXQgc2hvdWxkVW56aXBBcHAgPSBmYWxzZTtcbiAgbGV0IHBhY2thZ2VIYXNoID0gbnVsbDtcbiAgbGV0IGhlYWRlcnMgPSBudWxsO1xuICAvKiogQHR5cGUge1JlbW90ZUFwcFByb3BzfSAqL1xuICBjb25zdCByZW1vdGVBcHBQcm9wcyA9IHtcbiAgICBsYXN0TW9kaWZpZWQ6IG51bGwsXG4gICAgaW1tdXRhYmxlOiBmYWxzZSxcbiAgICBtYXhBZ2U6IG51bGwsXG4gIH07XG4gIGNvbnN0IHtwcm90b2NvbCwgcGF0aG5hbWV9ID0gdXJsLnBhcnNlKG5ld0FwcCk7XG4gIGNvbnN0IGlzVXJsID0gcHJvdG9jb2wgPT09IG51bGwgPyBmYWxzZSA6IFsnaHR0cDonLCAnaHR0cHM6J10uaW5jbHVkZXMocHJvdG9jb2wpO1xuXG4gIGNvbnN0IGNhY2hlZEFwcEluZm8gPSBBUFBMSUNBVElPTlNfQ0FDSEUuZ2V0KGFwcCk7XG5cbiAgcmV0dXJuIGF3YWl0IEFQUExJQ0FUSU9OU19DQUNIRV9HVUFSRC5hY3F1aXJlKGFwcCwgYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc1VybCkge1xuICAgICAgLy8gVXNlIHRoZSBhcHAgZnJvbSByZW1vdGUgVVJMXG4gICAgICBsb2dnZXIuaW5mbyhgVXNpbmcgZG93bmxvYWRhYmxlIGFwcCAnJHtuZXdBcHB9J2ApO1xuICAgICAgaGVhZGVycyA9IGF3YWl0IHJldHJpZXZlSGVhZGVycyhuZXdBcHApO1xuICAgICAgaWYgKCFfLmlzRW1wdHkoaGVhZGVycykpIHtcbiAgICAgICAgaWYgKGhlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSkge1xuICAgICAgICAgIHJlbW90ZUFwcFByb3BzLmxhc3RNb2RpZmllZCA9IG5ldyBEYXRlKGhlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBMYXN0LU1vZGlmaWVkOiAke2hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXX1gKTtcbiAgICAgICAgaWYgKGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSkge1xuICAgICAgICAgIHJlbW90ZUFwcFByb3BzLmltbXV0YWJsZSA9IC9cXGJpbW11dGFibGVcXGIvaS50ZXN0KGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSk7XG4gICAgICAgICAgY29uc3QgbWF4QWdlTWF0Y2ggPSAvXFxibWF4LWFnZT0oXFxkKylcXGIvaS5leGVjKGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSk7XG4gICAgICAgICAgaWYgKG1heEFnZU1hdGNoKSB7XG4gICAgICAgICAgICByZW1vdGVBcHBQcm9wcy5tYXhBZ2UgPSBwYXJzZUludChtYXhBZ2VNYXRjaFsxXSwgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoYENhY2hlLUNvbnRyb2w6ICR7aGVhZGVyc1snY2FjaGUtY29udHJvbCddfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGVkUGF0aCA9IGdldENhY2hlZEFwcGxpY2F0aW9uUGF0aChhcHAsIHJlbW90ZUFwcFByb3BzLCBjYWNoZWRBcHBJbmZvKTtcbiAgICAgIGlmIChjYWNoZWRQYXRoKSB7XG4gICAgICAgIGlmIChhd2FpdCBpc0FwcEludGVncml0eU9rKGNhY2hlZFBhdGgsIGNhY2hlZEFwcEluZm8/LmludGVncml0eSkpIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgUmV1c2luZyBwcmV2aW91c2x5IGRvd25sb2FkZWQgYXBwbGljYXRpb24gYXQgJyR7Y2FjaGVkUGF0aH0nYCk7XG4gICAgICAgICAgcmV0dXJuIHZlcmlmeUFwcEV4dGVuc2lvbihjYWNoZWRQYXRoLCBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICBgVGhlIGFwcGxpY2F0aW9uIGF0ICcke2NhY2hlZFBhdGh9JyBkb2VzIG5vdCBleGlzdCBhbnltb3JlIGAgK1xuICAgICAgICAgICAgYG9yIGl0cyBpbnRlZ3JpdHkgaGFzIGJlZW4gZGFtYWdlZC4gRGVsZXRpbmcgaXQgZnJvbSB0aGUgaW50ZXJuYWwgY2FjaGVgXG4gICAgICAgICk7XG4gICAgICAgIEFQUExJQ0FUSU9OU19DQUNIRS5kZWxldGUoYXBwKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGZpbGVOYW1lID0gbnVsbDtcbiAgICAgIGNvbnN0IGJhc2VuYW1lID0gZnMuc2FuaXRpemVOYW1lKHBhdGguYmFzZW5hbWUoZGVjb2RlVVJJQ29tcG9uZW50KHBhdGhuYW1lID8/ICcnKSksIHtcbiAgICAgICAgcmVwbGFjZW1lbnQ6IFNBTklUSVpFX1JFUExBQ0VNRU5ULFxuICAgICAgfSk7XG4gICAgICBjb25zdCBleHRuYW1lID0gcGF0aC5leHRuYW1lKGJhc2VuYW1lKTtcbiAgICAgIC8vIHRvIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIHVuemlwIHRoZSBhcHAsIHdlIGhhdmUgYSBudW1iZXIgb2YgcGxhY2VzXG4gICAgICAvLyB0byBsb29rOiBjb250ZW50IHR5cGUsIGNvbnRlbnQgZGlzcG9zaXRpb24sIG9yIHRoZSBmaWxlIGV4dGVuc2lvblxuICAgICAgaWYgKFpJUF9FWFRTLmluY2x1ZGVzKGV4dG5hbWUpKSB7XG4gICAgICAgIGZpbGVOYW1lID0gYmFzZW5hbWU7XG4gICAgICAgIHNob3VsZFVuemlwQXBwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICBjb25zdCBjdCA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICBsb2dnZXIuZGVidWcoYENvbnRlbnQtVHlwZTogJHtjdH1gKTtcbiAgICAgICAgLy8gdGhlIGZpbGV0eXBlIG1heSBub3QgYmUgb2J2aW91cyBmb3IgY2VydGFpbiB1cmxzLCBzbyBjaGVjayB0aGUgbWltZSB0eXBlIHRvb1xuICAgICAgICBpZiAoXG4gICAgICAgICAgWklQX01JTUVfVFlQRVMuc29tZSgobWltZVR5cGUpID0+XG4gICAgICAgICAgICBuZXcgUmVnRXhwKGBcXFxcYiR7Xy5lc2NhcGVSZWdFeHAobWltZVR5cGUpfVxcXFxiYCkudGVzdChjdClcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICghZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gYCR7REVGQVVMVF9CQVNFTkFNRX0uemlwYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2hvdWxkVW56aXBBcHAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGVhZGVyc1snY29udGVudC1kaXNwb3NpdGlvbiddICYmIC9eYXR0YWNobWVudC9pLnRlc3QoaGVhZGVyc1snY29udGVudC1kaXNwb3NpdGlvbiddKSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYENvbnRlbnQtRGlzcG9zaXRpb246ICR7aGVhZGVyc1snY29udGVudC1kaXNwb3NpdGlvbiddfWApO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9maWxlbmFtZT1cIihbXlwiXSspL2kuZXhlYyhoZWFkZXJzWydjb250ZW50LWRpc3Bvc2l0aW9uJ10pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBmaWxlTmFtZSA9IGZzLnNhbml0aXplTmFtZShtYXRjaFsxXSwge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQ6IFNBTklUSVpFX1JFUExBQ0VNRU5ULFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNob3VsZFVuemlwQXBwID0gc2hvdWxkVW56aXBBcHAgfHwgWklQX0VYVFMuaW5jbHVkZXMocGF0aC5leHRuYW1lKGZpbGVOYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZmlsZU5hbWUpIHtcbiAgICAgICAgLy8gYXNzaWduIHRoZSBkZWZhdWx0IGZpbGUgbmFtZSBhbmQgdGhlIGV4dGVuc2lvbiBpZiBub25lIGhhcyBiZWVuIGRldGVjdGVkXG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ05hbWUgPSBiYXNlbmFtZVxuICAgICAgICAgID8gYmFzZW5hbWUuc3Vic3RyaW5nKDAsIGJhc2VuYW1lLmxlbmd0aCAtIGV4dG5hbWUubGVuZ3RoKVxuICAgICAgICAgIDogREVGQVVMVF9CQVNFTkFNRTtcbiAgICAgICAgbGV0IHJlc3VsdGluZ0V4dCA9IGV4dG5hbWU7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucy5pbmNsdWRlcyhyZXN1bHRpbmdFeHQpKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICBgVGhlIGN1cnJlbnQgZmlsZSBleHRlbnNpb24gJyR7cmVzdWx0aW5nRXh0fScgaXMgbm90IHN1cHBvcnRlZC4gYCArXG4gICAgICAgICAgICAgIGBEZWZhdWx0aW5nIHRvICcke18uZmlyc3Qoc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyl9J2BcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdGluZ0V4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoXy5maXJzdChzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZU5hbWUgPSBgJHtyZXN1bHRpbmdOYW1lfSR7cmVzdWx0aW5nRXh0fWA7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRQYXRoID0gYXdhaXQgdGVtcERpci5wYXRoKHtcbiAgICAgICAgcHJlZml4OiBmaWxlTmFtZSxcbiAgICAgICAgc3VmZml4OiAnJyxcbiAgICAgIH0pO1xuICAgICAgbmV3QXBwID0gYXdhaXQgZG93bmxvYWRBcHAobmV3QXBwLCB0YXJnZXRQYXRoKTtcbiAgICB9IGVsc2UgaWYgKGF3YWl0IGZzLmV4aXN0cyhuZXdBcHApKSB7XG4gICAgICAvLyBVc2UgdGhlIGxvY2FsIGFwcFxuICAgICAgbG9nZ2VyLmluZm8oYFVzaW5nIGxvY2FsIGFwcCAnJHtuZXdBcHB9J2ApO1xuICAgICAgc2hvdWxkVW56aXBBcHAgPSBaSVBfRVhUUy5pbmNsdWRlcyhwYXRoLmV4dG5hbWUobmV3QXBwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgVGhlIGFwcGxpY2F0aW9uIGF0ICcke25ld0FwcH0nIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhY2Nlc3NpYmxlYDtcbiAgICAgIC8vIHByb3RvY29sIHZhbHVlIGZvciAnQzpcXFxcdGVtcCcgaXMgJ2M6Jywgc28gd2UgY2hlY2sgdGhlIGxlbmd0aCBhcyB3ZWxsXG4gICAgICBpZiAoXy5pc1N0cmluZyhwcm90b2NvbCkgJiYgcHJvdG9jb2wubGVuZ3RoID4gMikge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICAgIGBUaGUgcHJvdG9jb2wgJyR7cHJvdG9jb2x9JyB1c2VkIGluICcke25ld0FwcH0nIGlzIG5vdCBzdXBwb3J0ZWQuIGAgK1xuICAgICAgICAgIGBPbmx5IGh0dHA6IGFuZCBodHRwczogcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWRgO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNQYWNrYWdlQUZpbGUgPSAoYXdhaXQgZnMuc3RhdChuZXdBcHApKS5pc0ZpbGUoKTtcbiAgICBpZiAoaXNQYWNrYWdlQUZpbGUpIHtcbiAgICAgIHBhY2thZ2VIYXNoID0gYXdhaXQgY2FsY3VsYXRlRmlsZUludGVncml0eShuZXdBcHApO1xuICAgIH1cblxuICAgIGlmIChpc1BhY2thZ2VBRmlsZSAmJiBzaG91bGRVbnppcEFwcCAmJiAhXy5pc0Z1bmN0aW9uKG9uUG9zdFByb2Nlc3MpKSB7XG4gICAgICBjb25zdCBhcmNoaXZlUGF0aCA9IG5ld0FwcDtcbiAgICAgIGlmIChwYWNrYWdlSGFzaCA9PT0gY2FjaGVkQXBwSW5mbz8ucGFja2FnZUhhc2gpIHtcbiAgICAgICAgY29uc3Qge2Z1bGxQYXRofSA9IGNhY2hlZEFwcEluZm87XG4gICAgICAgIGlmIChhd2FpdCBpc0FwcEludGVncml0eU9rKGZ1bGxQYXRoLCBjYWNoZWRBcHBJbmZvPy5pbnRlZ3JpdHkpKSB7XG4gICAgICAgICAgaWYgKGFyY2hpdmVQYXRoICE9PSBhcHApIHtcbiAgICAgICAgICAgIGF3YWl0IGZzLnJpbXJhZihhcmNoaXZlUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5pbmZvKGBXaWxsIHJldXNlIHByZXZpb3VzbHkgY2FjaGVkIGFwcGxpY2F0aW9uIGF0ICcke2Z1bGxQYXRofSdgKTtcbiAgICAgICAgICByZXR1cm4gdmVyaWZ5QXBwRXh0ZW5zaW9uKGZ1bGxQYXRoLCBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICBgVGhlIGFwcGxpY2F0aW9uIGF0ICcke2Z1bGxQYXRofScgZG9lcyBub3QgZXhpc3QgYW55bW9yZSBgICtcbiAgICAgICAgICAgIGBvciBpdHMgaW50ZWdyaXR5IGhhcyBiZWVuIGRhbWFnZWQuIERlbGV0aW5nIGl0IGZyb20gdGhlIGNhY2hlYFxuICAgICAgICApO1xuICAgICAgICBBUFBMSUNBVElPTlNfQ0FDSEUuZGVsZXRlKGFwcCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gICAgICB0cnkge1xuICAgICAgICBuZXdBcHAgPSBhd2FpdCB1bnppcEFwcChhcmNoaXZlUGF0aCwgdG1wUm9vdCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobmV3QXBwICE9PSBhcmNoaXZlUGF0aCAmJiBhcmNoaXZlUGF0aCAhPT0gYXBwKSB7XG4gICAgICAgICAgYXdhaXQgZnMucmltcmFmKGFyY2hpdmVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9nZ2VyLmluZm8oYFVuemlwcGVkIGxvY2FsIGFwcCB0byAnJHtuZXdBcHB9J2ApO1xuICAgIH0gZWxzZSBpZiAoIXBhdGguaXNBYnNvbHV0ZShuZXdBcHApKSB7XG4gICAgICBuZXdBcHAgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgbmV3QXBwKTtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBgVGhlIGN1cnJlbnQgYXBwbGljYXRpb24gcGF0aCAnJHthcHB9JyBpcyBub3QgYWJzb2x1dGUgYCArXG4gICAgICAgICAgYGFuZCBoYXMgYmVlbiByZXdyaXR0ZW4gdG8gJyR7bmV3QXBwfScuIENvbnNpZGVyIHVzaW5nIGFic29sdXRlIHBhdGhzIHJhdGhlciB0aGFuIHJlbGF0aXZlYFxuICAgICAgKTtcbiAgICAgIGFwcCA9IG5ld0FwcDtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZUFwcEluQ2FjaGUgPSBhc3luYyAoYXBwUGF0aFRvQ2FjaGUpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlZEZ1bGxQYXRoID0gY2FjaGVkQXBwSW5mbz8uZnVsbFBhdGg7XG4gICAgICBpZiAoY2FjaGVkRnVsbFBhdGggJiYgY2FjaGVkRnVsbFBhdGggIT09IGFwcFBhdGhUb0NhY2hlKSB7XG4gICAgICAgIGF3YWl0IGZzLnJpbXJhZihjYWNoZWRGdWxsUGF0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnRlZ3JpdHkgPSB7fTtcbiAgICAgIGlmICgoYXdhaXQgZnMuc3RhdChhcHBQYXRoVG9DYWNoZSkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgaW50ZWdyaXR5LmZvbGRlciA9IGF3YWl0IGNhbGN1bGF0ZUZvbGRlckludGVncml0eShhcHBQYXRoVG9DYWNoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlZ3JpdHkuZmlsZSA9IGF3YWl0IGNhbGN1bGF0ZUZpbGVJbnRlZ3JpdHkoYXBwUGF0aFRvQ2FjaGUpO1xuICAgICAgfVxuICAgICAgQVBQTElDQVRJT05TX0NBQ0hFLnNldChhcHAsIHtcbiAgICAgICAgLi4ucmVtb3RlQXBwUHJvcHMsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgcGFja2FnZUhhc2gsXG4gICAgICAgIGludGVncml0eSxcbiAgICAgICAgZnVsbFBhdGg6IGFwcFBhdGhUb0NhY2hlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXBwUGF0aFRvQ2FjaGU7XG4gICAgfTtcblxuICAgIGlmIChfLmlzRnVuY3Rpb24ob25Qb3N0UHJvY2VzcykpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9uUG9zdFByb2Nlc3Moe1xuICAgICAgICBjYWNoZWRBcHBJbmZvOiBfLmNsb25lKGNhY2hlZEFwcEluZm8pLFxuICAgICAgICBpc1VybCxcbiAgICAgICAgaGVhZGVyczogXy5jbG9uZShoZWFkZXJzKSxcbiAgICAgICAgYXBwUGF0aDogbmV3QXBwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gIXJlc3VsdD8uYXBwUGF0aCB8fCBhcHAgPT09IHJlc3VsdD8uYXBwUGF0aCB8fCAhKGF3YWl0IGZzLmV4aXN0cyhyZXN1bHQ/LmFwcFBhdGgpKVxuICAgICAgICA/IG5ld0FwcFxuICAgICAgICA6IGF3YWl0IHN0b3JlQXBwSW5DYWNoZShyZXN1bHQuYXBwUGF0aCk7XG4gICAgfVxuXG4gICAgdmVyaWZ5QXBwRXh0ZW5zaW9uKG5ld0FwcCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyk7XG4gICAgcmV0dXJuIGFwcCAhPT0gbmV3QXBwICYmIChwYWNrYWdlSGFzaCB8fCBfLnZhbHVlcyhyZW1vdGVBcHBQcm9wcykuc29tZShCb29sZWFuKSlcbiAgICAgID8gYXdhaXQgc3RvcmVBcHBJbkNhY2hlKG5ld0FwcClcbiAgICAgIDogbmV3QXBwO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRBcHAoYXBwLCB0YXJnZXRQYXRoKSB7XG4gIGNvbnN0IHtocmVmfSA9IHVybC5wYXJzZShhcHApO1xuICB0cnkge1xuICAgIGF3YWl0IG5ldC5kb3dubG9hZEZpbGUoaHJlZiwgdGFyZ2V0UGF0aCwge1xuICAgICAgdGltZW91dDogQVBQX0RPV05MT0FEX1RJTUVPVVRfTVMsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGRvd25sb2FkIHRoZSBhcHA6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFBhdGg7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGJ1bmRsZSBmcm9tIGFuIGFyY2hpdmUgaW50byB0aGUgZ2l2ZW4gZm9sZGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHppcFBhdGggRnVsbCBwYXRoIHRvIHRoZSBhcmNoaXZlIGNvbnRhaW5pbmcgdGhlIGJ1bmRsZVxuICogQHBhcmFtIHtzdHJpbmd9IGRzdFJvb3QgRnVsbCBwYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIGV4dHJhY3RlZCBidW5kbGVcbiAqIHNob3VsZCBiZSBwbGFjZWRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPnxzdHJpbmd9IHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMgVGhlIGxpc3Qgb2YgZXh0ZW5zaW9uc1xuICogdGhlIHRhcmdldCBhcHBsaWNhdGlvbiBidW5kbGUgc3VwcG9ydHMsIGZvciBleGFtcGxlIFsnLmFwaycsICcuYXBrcyddIGZvclxuICogQW5kcm9pZCBwYWNrYWdlc1xuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gRnVsbCBwYXRoIHRvIHRoZSBidW5kbGUgaW4gdGhlIGRlc3RpbmF0aW9uIGZvbGRlclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBnaXZlbiBhcmNoaXZlIGlzIGludmFsaWQgb3Igbm8gYXBwbGljYXRpb24gYnVuZGxlc1xuICogaGF2ZSBiZWVuIGZvdW5kIGluc2lkZVxuICovXG5hc3luYyBmdW5jdGlvbiB1bnppcEFwcCh6aXBQYXRoLCBkc3RSb290LCBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKSB7XG4gIGF3YWl0IHppcC5hc3NlcnRWYWxpZFppcCh6aXBQYXRoKTtcblxuICBpZiAoIV8uaXNBcnJheShzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKSkge1xuICAgIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMgPSBbc3VwcG9ydGVkQXBwRXh0ZW5zaW9uc107XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIHRyeSB7XG4gICAgbG9nZ2VyLmRlYnVnKGBVbnppcHBpbmcgJyR7emlwUGF0aH0nYCk7XG4gICAgY29uc3QgdGltZXIgPSBuZXcgdGltaW5nLlRpbWVyKCkuc3RhcnQoKTtcbiAgICBjb25zdCB1c2VTeXN0ZW1VbnppcEVudiA9IHByb2Nlc3MuZW52LkFQUElVTV9QUkVGRVJfU1lTVEVNX1VOWklQO1xuICAgIGNvbnN0IHVzZVN5c3RlbVVuemlwID1cbiAgICAgIF8uaXNFbXB0eSh1c2VTeXN0ZW1VbnppcEVudikgfHwgIVsnMCcsICdmYWxzZSddLmluY2x1ZGVzKF8udG9Mb3dlcih1c2VTeXN0ZW1VbnppcEVudikpO1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gdXNlIHVzZSB0aGUgc3lzdGVtIGB1bnppcGAgKGUuZy4sIGAvdXNyL2Jpbi91bnppcGApIGR1ZVxuICAgICAqIHRvIHRoZSBzaWduaWZpY2FudCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudCBpdCBwcm92aWRlcyBvdmVyIHRoZSBuYXRpdmVcbiAgICAgKiBKUyBcInVuemlwXCIgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHR5cGUge2ltcG9ydCgnQGFwcGl1bS9zdXBwb3J0L2xpYi96aXAnKS5FeHRyYWN0QWxsT3B0aW9uc31cbiAgICAgKi9cbiAgICBjb25zdCBleHRyYWN0aW9uT3B0cyA9IHt1c2VTeXN0ZW1VbnppcH07XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzE0MTAwXG4gICAgaWYgKHBhdGguZXh0bmFtZSh6aXBQYXRoKSA9PT0gSVBBX0VYVCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgRW5mb3JjaW5nIFVURi04IGVuY29kaW5nIG9uIHRoZSBleHRyYWN0ZWQgZmlsZSBuYW1lcyBmb3IgJyR7cGF0aC5iYXNlbmFtZSh6aXBQYXRoKX0nYFxuICAgICAgKTtcbiAgICAgIGV4dHJhY3Rpb25PcHRzLmZpbGVOYW1lc0VuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH1cbiAgICBhd2FpdCB6aXAuZXh0cmFjdEFsbFRvKHppcFBhdGgsIHRtcFJvb3QsIGV4dHJhY3Rpb25PcHRzKTtcbiAgICBjb25zdCBnbG9iUGF0dGVybiA9IGAqKi8qLisoJHtzdXBwb3J0ZWRBcHBFeHRlbnNpb25zXG4gICAgICAubWFwKChleHQpID0+IGV4dC5yZXBsYWNlKC9eXFwuLywgJycpKVxuICAgICAgLmpvaW4oJ3wnKX0pYDtcbiAgICBjb25zdCBzb3J0ZWRCdW5kbGVJdGVtcyA9IChcbiAgICAgIGF3YWl0IGZzLmdsb2IoZ2xvYlBhdHRlcm4sIHtcbiAgICAgICAgY3dkOiB0bXBSb290LFxuICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAvLyBHZXQgdGhlIHRvcCBsZXZlbCBtYXRjaFxuICAgICAgfSlcbiAgICApLnNvcnQoKGEsIGIpID0+IGEuc3BsaXQocGF0aC5zZXApLmxlbmd0aCAtIGIuc3BsaXQocGF0aC5zZXApLmxlbmd0aCk7XG4gICAgaWYgKF8uaXNFbXB0eShzb3J0ZWRCdW5kbGVJdGVtcykpIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KFxuICAgICAgICBgQXBwIHVuemlwcGVkIE9LLCBidXQgd2UgY291bGQgbm90IGZpbmQgYW55ICcke3N1cHBvcnRlZEFwcEV4dGVuc2lvbnN9JyBgICtcbiAgICAgICAgICB1dGlsLnBsdXJhbGl6ZSgnYnVuZGxlJywgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucy5sZW5ndGgsIGZhbHNlKSArXG4gICAgICAgICAgYCBpbiBpdC4gTWFrZSBzdXJlIHlvdXIgYXJjaGl2ZSBjb250YWlucyBhdCBsZWFzdCBvbmUgcGFja2FnZSBoYXZpbmcgYCArXG4gICAgICAgICAgYCcke3N1cHBvcnRlZEFwcEV4dGVuc2lvbnN9JyAke3V0aWwucGx1cmFsaXplKFxuICAgICAgICAgICAgJ2V4dGVuc2lvbicsXG4gICAgICAgICAgICBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zLmxlbmd0aCxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgRXh0cmFjdGVkICR7dXRpbC5wbHVyYWxpemUoJ2J1bmRsZSBpdGVtJywgc29ydGVkQnVuZGxlSXRlbXMubGVuZ3RoLCB0cnVlKX0gYCArXG4gICAgICAgIGBmcm9tICcke3ppcFBhdGh9JyBpbiAke01hdGgucm91bmQoXG4gICAgICAgICAgdGltZXIuZ2V0RHVyYXRpb24oKS5hc01pbGxpU2Vjb25kc1xuICAgICAgICApfW1zOiAke3NvcnRlZEJ1bmRsZUl0ZW1zfWBcbiAgICApO1xuICAgIGNvbnN0IG1hdGNoZWRCdW5kbGUgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKF8uZmlyc3Qoc29ydGVkQnVuZGxlSXRlbXMpKTtcbiAgICBsb2dnZXIuaW5mbyhgQXNzdW1pbmcgJyR7bWF0Y2hlZEJ1bmRsZX0nIGlzIHRoZSBjb3JyZWN0IGJ1bmRsZWApO1xuICAgIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoZHN0Um9vdCwgcGF0aC5iYXNlbmFtZShtYXRjaGVkQnVuZGxlKSk7XG4gICAgYXdhaXQgZnMubXYocGF0aC5yZXNvbHZlKHRtcFJvb3QsIG1hdGNoZWRCdW5kbGUpLCBkc3RQYXRoLCB7bWtkaXJwOiB0cnVlfSk7XG4gICAgcmV0dXJuIGRzdFBhdGg7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUGFja2FnZU9yQnVuZGxlKGFwcCkge1xuICByZXR1cm4gL14oW2EtekEtWjAtOVxcLV9dK1xcLlthLXpBLVowLTlcXC1fXSspKyQvLnRlc3QoYXBwKTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhbGwgaW5zdGFuY2VzICdmaXJzdEtleScgYW5kIGNyZWF0ZSBhIGR1cGxpY2F0ZSB3aXRoIHRoZSBrZXkgJ3NlY29uZEtleScsXG4gKiBEbyB0aGUgc2FtZSB0aGluZyBpbiByZXZlcnNlLiBJZiB3ZSBmaW5kICdzZWNvbmRLZXknLCBjcmVhdGUgYSBkdXBsaWNhdGUgd2l0aCB0aGUga2V5ICdmaXJzdEtleScuXG4gKlxuICogVGhpcyB3aWxsIGNhdXNlIGtleXMgdG8gYmUgb3ZlcndyaXR0ZW4gaWYgdGhlIG9iamVjdCBjb250YWlucyAnZmlyc3RLZXknIGFuZCAnc2Vjb25kS2V5Jy5cblxuICogQHBhcmFtIHsqfSBpbnB1dCBBbnkgdHlwZSBvZiBpbnB1dFxuICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0S2V5IFRoZSBmaXJzdCBrZXkgdG8gZHVwbGljYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2Vjb25kS2V5IFRoZSBzZWNvbmQga2V5IHRvIGR1cGxpY2F0ZVxuICovXG5mdW5jdGlvbiBkdXBsaWNhdGVLZXlzKGlucHV0LCBmaXJzdEtleSwgc2Vjb25kS2V5KSB7XG4gIC8vIElmIGFycmF5IHByb3ZpZGVkLCByZWN1cnNpdmVseSBjYWxsIG9uIGFsbCBlbGVtZW50c1xuICBpZiAoXy5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IGR1cGxpY2F0ZUtleXMoaXRlbSwgZmlyc3RLZXksIHNlY29uZEtleSkpO1xuICB9XG5cbiAgLy8gSWYgb2JqZWN0LCBjcmVhdGUgZHVwbGljYXRlcyBmb3Iga2V5cyBhbmQgdGhlbiByZWN1cnNpdmVseSBjYWxsIG9uIHZhbHVlc1xuICBpZiAoXy5pc1BsYWluT2JqZWN0KGlucHV0KSkge1xuICAgIGNvbnN0IHJlc3VsdE9iaiA9IHt9O1xuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBfLnRvUGFpcnMoaW5wdXQpKSB7XG4gICAgICBjb25zdCByZWN1cnNpdmVseUNhbGxlZFZhbHVlID0gZHVwbGljYXRlS2V5cyh2YWx1ZSwgZmlyc3RLZXksIHNlY29uZEtleSk7XG4gICAgICBpZiAoa2V5ID09PSBmaXJzdEtleSkge1xuICAgICAgICByZXN1bHRPYmpbc2Vjb25kS2V5XSA9IHJlY3Vyc2l2ZWx5Q2FsbGVkVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gc2Vjb25kS2V5KSB7XG4gICAgICAgIHJlc3VsdE9ialtmaXJzdEtleV0gPSByZWN1cnNpdmVseUNhbGxlZFZhbHVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0T2JqW2tleV0gPSByZWN1cnNpdmVseUNhbGxlZFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0T2JqO1xuICB9XG5cbiAgLy8gQmFzZSBjYXNlLiBSZXR1cm4gcHJpbWl0aXZlcyB3aXRob3V0IGRvaW5nIGFueXRoaW5nLlxuICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogVGFrZXMgYSBkZXNpcmVkIGNhcGFiaWxpdHkgYW5kIHRyaWVzIHRvIEpTT04ucGFyc2UgaXQgYXMgYW4gYXJyYXksXG4gKiBhbmQgZWl0aGVyIHJldHVybnMgdGhlIHBhcnNlZCBhcnJheSBvciBhIHNpbmdsZXRvbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxTdHJpbmc+fSBjYXAgQSBkZXNpcmVkIGNhcGFiaWxpdHlcbiAqL1xuZnVuY3Rpb24gcGFyc2VDYXBzQXJyYXkoY2FwKSB7XG4gIGlmIChfLmlzQXJyYXkoY2FwKSkge1xuICAgIHJldHVybiBjYXA7XG4gIH1cblxuICBsZXQgcGFyc2VkQ2FwcztcbiAgdHJ5IHtcbiAgICBwYXJzZWRDYXBzID0gSlNPTi5wYXJzZShjYXApO1xuICAgIGlmIChfLmlzQXJyYXkocGFyc2VkQ2FwcykpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDYXBzO1xuICAgIH1cbiAgfSBjYXRjaCAoaWduKSB7XG4gICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byBwYXJzZSBjYXBhYmlsaXR5IGFzIEpTT04gYXJyYXlgKTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhjYXApKSB7XG4gICAgcmV0dXJuIFtjYXBdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgbXVzdCBwcm92aWRlIGEgc3RyaW5nIG9yIEpTT04gQXJyYXk7IHJlY2VpdmVkICR7Y2FwfWApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIHRoYXQgdW5pcXVlbHkgZGVzY3JpYmVzIGRyaXZlciBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCdAYXBwaXVtL3R5cGVzJykuQ29yZX0gb2JqIGRyaXZlciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmc/fSBzZXNzaW9uSWQgc2Vzc2lvbiBpZGVudGlmaWVyIChpZiBleGlzdHMpXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZURyaXZlckxvZ1ByZWZpeChvYmosIHNlc3Npb25JZCA9IG51bGwpIHtcbiAgY29uc3QgaW5zdGFuY2VOYW1lID0gYCR7b2JqLmNvbnN0cnVjdG9yLm5hbWV9QCR7bm9kZS5nZXRPYmplY3RJZChvYmopLnN1YnN0cmluZygwLCA0KX1gO1xuICByZXR1cm4gc2Vzc2lvbklkID8gYCR7aW5zdGFuY2VOYW1lfSAoJHtzZXNzaW9uSWQuc3Vic3RyaW5nKDAsIDgpfSlgIDogaW5zdGFuY2VOYW1lO1xufVxuXG4vKiogQHR5cGUge2ltcG9ydCgnQGFwcGl1bS90eXBlcycpLkRyaXZlckhlbHBlcnN9ICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbmZpZ3VyZUFwcCxcbiAgaXNQYWNrYWdlT3JCdW5kbGUsXG4gIGR1cGxpY2F0ZUtleXMsXG4gIHBhcnNlQ2Fwc0FycmF5LFxuICBnZW5lcmF0ZURyaXZlckxvZ1ByZWZpeCxcbn07XG5leHBvcnQge2NvbmZpZ3VyZUFwcCwgaXNQYWNrYWdlT3JCdW5kbGUsIGR1cGxpY2F0ZUtleXMsIHBhcnNlQ2Fwc0FycmF5LCBnZW5lcmF0ZURyaXZlckxvZ1ByZWZpeH07XG5cbi8qKlxuICogQHR5cGVkZWYgUmVtb3RlQXBwUHJvcHNcbiAqIEBwcm9wZXJ0eSB7RGF0ZT99IGxhc3RNb2RpZmllZFxuICogQHByb3BlcnR5IHtib29sZWFufSBpbW11dGFibGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyP30gbWF4QWdlXG4gKi9cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLE9BQU8sR0FBRyxNQUFoQjtBQUNBLE1BQU1DLFFBQVEsR0FBRyxDQUFDLE1BQUQsRUFBU0QsT0FBVCxDQUFqQjtBQUNBLE1BQU1FLGNBQWMsR0FBRyxDQUFDLGlCQUFELEVBQW9CLDhCQUFwQixFQUFvRCxpQkFBcEQsQ0FBdkI7QUFDQSxNQUFNQyxtQkFBbUIsR0FBRyxPQUFPLEVBQVAsR0FBWSxFQUFaLEdBQWlCLEVBQTdDO0FBQ0EsTUFBTUMsZUFBZSxHQUFHLElBQXhCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsSUFBSUMsaUJBQUosQ0FBUTtFQUNqQ0MsR0FBRyxFQUFFSCxlQUQ0QjtFQUVqQ0ksR0FBRyxFQUFFTCxtQkFGNEI7RUFHakNNLGNBQWMsRUFBRSxJQUhpQjtFQUlqQ0MsT0FBTyxFQUFFLENBQUNDLEdBQUQsRUFBTTtJQUFDQztFQUFELENBQU4sS0FBcUI7SUFDNUJDLGVBQUEsQ0FBT0MsSUFBUCxDQUNHLG9CQUFtQkgsR0FBSSxnQkFBZUMsUUFBUyxRQUFoRCxH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