"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.default = void 0;
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toArchive = toArchive;
exports.toInMemoryZip = toInMemoryZip;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

var _system = require("./system");

var _base64Stream = require("base64-stream");

var _util = require("./util");

var _timing = _interopRequireDefault(require("./timing"));

var _logger = _interopRequireDefault(require("./logger"));

var _getStream = _interopRequireDefault(require("get-stream"));

var _teen_process = require("teen_process");

const openZip = _bluebird.default.promisify(_yauzl.default.open);

const pipeline = _bluebird.default.promisify(_stream.default.pipeline);

const ZIP_MAGIC = 'PK';
const IFMT = 61440;
const IFDIR = 16384;
const IFLNK = 40960;

class ZipExtractor {
  zipfile;

  constructor(sourcePath, opts = {}) {
    this.zipPath = sourcePath;
    this.opts = opts;
    this.canceled = false;
  }

  extractFileName(entry) {
    return _lodash.default.isBuffer(entry.fileName) ? entry.fileName.toString(this.opts.fileNamesEncoding) : entry.fileName;
  }

  async extract() {
    const {
      dir,
      fileNamesEncoding
    } = this.opts;
    this.zipfile = await openZip(this.zipPath, {
      lazyEntries: true,
      decodeStrings: !fileNamesEncoding
    });
    this.canceled = false;
    return new _bluebird.default((resolve, reject) => {
      this.zipfile.on('error', err => {
        this.canceled = true;
        reject(err);
      });
      this.zipfile.readEntry();
      this.zipfile.on('close', () => {
        if (!this.canceled) {
          resolve();
        }
      });
      this.zipfile.on('entry', async entry => {
        if (this.canceled) {
          return;
        }

        const fileName = this.extractFileName(entry);

        if (fileName.startsWith('__MACOSX/')) {
          this.zipfile.readEntry();
          return;
        }

        const destDir = _path.default.dirname(_path.default.join(dir, fileName));

        try {
          await _fs2.default.mkdir(destDir, {
            recursive: true
          });
          const canonicalDestDir = await _fs2.default.realpath(destDir);

          const relativeDestDir = _path.default.relative(dir, canonicalDestDir);

          if (relativeDestDir.split(_path.default.sep).includes('..')) {
            new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${fileName}`);
          }

          await this.extractEntry(entry);
          this.zipfile.readEntry();
        } catch (err) {
          this.canceled = true;
          this.zipfile.close();
          reject(err);
        }
      });
    });
  }

  async extractEntry(entry) {
    if (this.canceled) {
      return;
    }

    const {
      dir
    } = this.opts;
    const fileName = this.extractFileName(entry);

    const dest = _path.default.join(dir, fileName);

    const mode = entry.externalFileAttributes >> 16 & 0xffff;
    const isSymlink = (mode & IFMT) === IFLNK;
    const isDir = (mode & IFMT) === IFDIR || fileName.endsWith('/') || entry.versionMadeBy >> 8 === 0 && entry.externalFileAttributes === 16;
    const procMode = this.getExtractedMode(mode, isDir) & 0o777;
    const destDir = isDir ? dest : _path.default.dirname(dest);
    const mkdirOptions = {
      recursive: true
    };

    if (isDir) {
      mkdirOptions.mode = procMode;
    }

    await _fs2.default.mkdir(destDir, mkdirOptions);

    if (isDir) {
      return;
    }

    const openReadStream = _bluebird.default.promisify(this.zipfile.openReadStream.bind(this.zipfile));

    const readStream = await openReadStream(entry);

    if (isSymlink) {
      const link = await (0, _getStream.default)(readStream);
      await _fs2.default.symlink(link, dest);
    } else {
      await pipeline(readStream, _fs2.default.createWriteStream(dest, {
        mode: procMode
      }));
    }
  }

  getExtractedMode(entryMode, isDir) {
    const {
      defaultDirMode,
      defaultFileMode
    } = this.opts;
    let mode = entryMode;

    if (mode === 0) {
      if (isDir) {
        if (defaultDirMode) {
          mode = parseInt(defaultDirMode, 10);
        }

        if (!mode) {
          mode = 0o755;
        }
      } else {
        if (defaultFileMode) {
          mode = parseInt(defaultFileMode, 10);
        }

        if (!mode) {
          mode = 0o644;
        }
      }
    }

    return mode;
  }

}

async function extractAllTo(zipFilePath, destDir, opts = {}) {
  if (!_path.default.isAbsolute(destDir)) {
    throw new Error(`Target path '${destDir}' is expected to be absolute`);
  }

  await _fs2.default.mkdir(destDir, {
    recursive: true
  });
  const dir = await _fs2.default.realpath(destDir);

  if (opts.useSystemUnzip) {
    try {
      await extractWithSystemUnzip(zipFilePath, dir);
      return;
    } catch (err) {
      _logger.default.warn('unzip failed; falling back to JS: %s', err.stderr || err.message);
    }
  }

  const extractor = new ZipExtractor(zipFilePath, { ...opts,
    dir
  });
  await extractor.extract();
}

async function extractWithSystemUnzip(zipFilePath, destDir) {
  const isWindowsHost = (0, _system.isWindows)();
  let executablePath;

  try {
    executablePath = await getExecutablePath(isWindowsHost ? 'powershell.exe' : 'unzip');
  } catch (e) {
    throw new Error('Could not find system unzip');
  }

  if (isWindowsHost) {
    await (0, _teen_process.exec)(executablePath, ['-command', 'Expand-Archive', '-LiteralPath', zipFilePath, '-DestinationPath', destDir, '-Force']);
  } else {
    await (0, _teen_process.exec)(executablePath, ['-q', '-o', zipFilePath, '-d', destDir]);
  }
}

async function _extractEntryTo(zipFile, entry, destDir) {
  const dstPath = _path.default.resolve(destDir, entry.fileName);

  if (/\/$/.test(entry.fileName)) {
    if (!(await _fs2.default.exists(dstPath))) {
      await _fs2.default.mkdirp(dstPath);
    }

    return;
  } else if (!(await _fs2.default.exists(_path.default.dirname(dstPath)))) {
    await _fs2.default.mkdirp(_path.default.dirname(dstPath));
  }

  const writeStream = (0, _fs.createWriteStream)(dstPath, {
    flags: 'w'
  });
  const writeStreamPromise = new _bluebird.default((resolve, reject) => {
    writeStream.once('finish', resolve);
    writeStream.once('error', reject);
  });
  const zipReadStream = await new _bluebird.default((resolve, reject) => {
    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipReadStream.once('end', resolve);
    zipReadStream.once('error', reject);
  });
  zipReadStream.pipe(writeStream);
  return await _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
}

async function readEntries(zipFilePath, onEntry) {
  const zipfile = await openZip(zipFilePath, {
    lazyEntries: true
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipfile.once('end', resolve);
    zipfile.once('error', reject);
    zipfile.on('entry', async entry => {
      const res = await onEntry({
        entry,
        extractEntryTo: async destDir => await _extractEntryTo(zipfile, entry, destDir)
      });

      if (res === false) {
        return zipfile.emit('end');
      }

      zipfile.readEntry();
    });
  });
  zipfile.readEntry();
  return await zipReadStreamPromise;
}

async function toInMemoryZip(srcPath, opts = {}) {
  if (!(await _fs2.default.exists(srcPath))) {
    throw new Error(`No such file or folder: ${srcPath}`);
  }

  const {
    isMetered = true,
    encodeToBase64 = false,
    maxSize = 1 * _util.GiB,
    level = 9
  } = opts;
  const resultBuffers = [];
  let resultBuffersSize = 0;
  const resultWriteStream = new _stream.default.Writable({
    write: (buffer, encoding, next) => {
      resultBuffers.push(buffer);
      resultBuffersSize += buffer.length;

      if (maxSize > 0 && resultBuffersSize > maxSize) {
        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `archive must not be greater than ${(0, _util.toReadableSizeString)(maxSize)}`));
      }

      next();
    }
  });
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });
  let srcSize = null;
  const base64EncoderStream = encodeToBase64 ? new _base64Stream.Base64Encode() : null;
  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {
    resultWriteStream.once('error', e => {
      if (base64EncoderStream) {
        archive.unpipe(base64EncoderStream);
        base64EncoderStream.unpipe(resultWriteStream);
      } else {
        archive.unpipe(resultWriteStream);
      }

      archive.abort();
      archive.destroy();
      reject(e);
    });
    resultWriteStream.once('finish', () => {
      srcSize = archive.pointer();
      resolve();
    });
  });
  const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
    archive.once('finish', resolve);
    archive.once('error', e => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));
  });
  const timer = isMetered ? new _timing.default().start() : null;

  if ((await _fs2.default.stat(srcPath)).isDirectory()) {
    archive.directory(srcPath, false);
  } else {
    archive.file(srcPath, {
      name: _path.default.basename(srcPath)
    });
  }

  if (base64EncoderStream) {
    archive.pipe(base64EncoderStream);
    base64EncoderStream.pipe(resultWriteStream);
  } else {
    archive.pipe(resultWriteStream);
  }

  archive.finalize();
  await _bluebird.default.all([archiveStreamPromise, resultWriteStreamPromise]);

  if (timer) {
    _logger.default.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` + `'${_path.default.basename(srcPath)}' ` + (srcSize ? `(${(0, _util.toReadableSizeString)(srcSize)}) ` : '') + `in ${timer.getDuration().asSeconds.toFixed(3)}s ` + `(compression level: ${level})`);
  }

  return Buffer.concat(resultBuffers);
}

async function assertValidZip(filePath) {
  if (!(await _fs2.default.exists(filePath))) {
    throw new Error(`The file at '${filePath}' does not exist`);
  }

  const {
    size
  } = await _fs2.default.stat(filePath);

  if (size < 4) {
    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
  }

  const fd = await _fs2.default.open(filePath, 'r');

  try {
    const buffer = Buffer.alloc(ZIP_MAGIC.length);
    await _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
    const signature = buffer.toString('ascii');

    if (signature !== ZIP_MAGIC) {
      throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
    }

    return true;
  } finally {
    await _fs2.default.close(fd);
  }
}

async function toArchive(dstPath, src = {}, opts = {}) {
  const {
    level = 9
  } = opts;
  const {
    pattern = '**/*',
    cwd = _path.default.dirname(dstPath),
    ignore = []
  } = src;
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });

  const stream = _fs2.default.createWriteStream(dstPath);

  return await new _bluebird.default((resolve, reject) => {
    archive.glob(pattern, {
      cwd,
      ignore
    }).on('error', reject).pipe(stream);
    stream.on('error', e => {
      archive.unpipe(stream);
      archive.abort();
      archive.destroy();
      reject(e);
    }).on('finish', resolve);
    archive.finalize();
  });
}

const getExecutablePath = _lodash.default.memoize(async function getExecutablePath(binaryName) {
  const fullPath = await _fs2.default.which(binaryName);

  _logger.default.debug(`Found '%s' at '%s'`, binaryName, fullPath);

  return fullPath;
});

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip,
  toArchive
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJvcGVuWmlwIiwiQiIsInByb21pc2lmeSIsInlhdXpsIiwib3BlbiIsInBpcGVsaW5lIiwic3RyZWFtIiwiWklQX01BR0lDIiwiSUZNVCIsIklGRElSIiwiSUZMTksiLCJaaXBFeHRyYWN0b3IiLCJ6aXBmaWxlIiwiY29uc3RydWN0b3IiLCJzb3VyY2VQYXRoIiwib3B0cyIsInppcFBhdGgiLCJjYW5jZWxlZCIsImV4dHJhY3RGaWxlTmFtZSIsImVudHJ5IiwiXyIsImlzQnVmZmVyIiwiZmlsZU5hbWUiLCJ0b1N0cmluZyIsImZpbGVOYW1lc0VuY29kaW5nIiwiZXh0cmFjdCIsImRpciIsImxhenlFbnRyaWVzIiwiZGVjb2RlU3RyaW5ncyIsInJlc29sdmUiLCJyZWplY3QiLCJvbiIsImVyciIsInJlYWRFbnRyeSIsInN0YXJ0c1dpdGgiLCJkZXN0RGlyIiwicGF0aCIsImRpcm5hbWUiLCJqb2luIiwiZnMiLCJta2RpciIsInJlY3Vyc2l2ZSIsImNhbm9uaWNhbERlc3REaXIiLCJyZWFscGF0aCIsInJlbGF0aXZlRGVzdERpciIsInJlbGF0aXZlIiwic3BsaXQiLCJzZXAiLCJpbmNsdWRlcyIsIkVycm9yIiwiZXh0cmFjdEVudHJ5IiwiY2xvc2UiLCJkZXN0IiwibW9kZSIsImV4dGVybmFsRmlsZUF0dHJpYnV0ZXMiLCJpc1N5bWxpbmsiLCJpc0RpciIsImVuZHNXaXRoIiwidmVyc2lvbk1hZGVCeSIsInByb2NNb2RlIiwiZ2V0RXh0cmFjdGVkTW9kZSIsIm1rZGlyT3B0aW9ucyIsIm9wZW5SZWFkU3RyZWFtIiwiYmluZCIsInJlYWRTdHJlYW0iLCJsaW5rIiwiZ2V0U3RyZWFtIiwic3ltbGluayIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiZW50cnlNb2RlIiwiZGVmYXVsdERpck1vZGUiLCJkZWZhdWx0RmlsZU1vZGUiLCJwYXJzZUludCIsImV4dHJhY3RBbGxUbyIsInppcEZpbGVQYXRoIiwiaXNBYnNvbHV0ZSIsInVzZVN5c3RlbVVuemlwIiwiZXh0cmFjdFdpdGhTeXN0ZW1VbnppcCIsImxvZyIsIndhcm4iLCJzdGRlcnIiLCJtZXNzYWdlIiwiZXh0cmFjdG9yIiwiaXNXaW5kb3dzSG9zdCIsImlzV2luZG93cyIsImV4ZWN1dGFibGVQYXRoIiwiZ2V0RXhlY3V0YWJsZVBhdGgiLCJlIiwiZXhlYyIsIl9leHRyYWN0RW50cnlUbyIsInppcEZpbGUiLCJkc3RQYXRoIiwidGVzdCIsImV4aXN0cyIsIm1rZGlycCIsIndyaXRlU3RyZWFtIiwiZmxhZ3MiLCJ3cml0ZVN0cmVhbVByb21pc2UiLCJvbmNlIiwiemlwUmVhZFN0cmVhbSIsInppcFJlYWRTdHJlYW1Qcm9taXNlIiwicGlwZSIsImFsbCIsInJlYWRFbnRyaWVzIiwib25FbnRyeSIsInJlcyIsImV4dHJhY3RFbnRyeVRvIiwiZW1pdCIsInRvSW5NZW1vcnlaaXAiLCJzcmNQYXRoIiwiaXNNZXRlcmVkIiwiZW5jb2RlVG9CYXNlNjQiLCJtYXhTaXplIiwiR2lCIiwibGV2ZWwiLCJyZXN1bHRCdWZmZXJzIiwicmVzdWx0QnVmZmVyc1NpemUiLCJyZXN1bHRXcml0ZVN0cmVhbSIsIldyaXRhYmxlIiwid3JpdGUiLCJidWZmZXIiLCJlbmNvZGluZyIsIm5leHQiLCJwdXNoIiwibGVuZ3RoIiwidG9SZWFkYWJsZVNpemVTdHJpbmciLCJhcmNoaXZlIiwiYXJjaGl2ZXIiLCJ6bGliIiwic3JjU2l6ZSIsImJhc2U2NEVuY29kZXJTdHJlYW0iLCJCYXNlNjRFbmNvZGUiLCJyZXN1bHRXcml0ZVN0cmVhbVByb21pc2UiLCJ1bnBpcGUiLCJhYm9ydCIsImRlc3Ryb3kiLCJwb2ludGVyIiwiYXJjaGl2ZVN0cmVhbVByb21pc2UiLCJ0aW1lciIsIlRpbWVyIiwic3RhcnQiLCJzdGF0IiwiaXNEaXJlY3RvcnkiLCJkaXJlY3RvcnkiLCJmaWxlIiwibmFtZSIsImJhc2VuYW1lIiwiZmluYWxpemUiLCJkZWJ1ZyIsImdldER1cmF0aW9uIiwiYXNTZWNvbmRzIiwidG9GaXhlZCIsIkJ1ZmZlciIsImNvbmNhdCIsImFzc2VydFZhbGlkWmlwIiwiZmlsZVBhdGgiLCJzaXplIiwiZmQiLCJhbGxvYyIsInJlYWQiLCJzaWduYXR1cmUiLCJ0b0FyY2hpdmUiLCJzcmMiLCJwYXR0ZXJuIiwiY3dkIiwiaWdub3JlIiwiZ2xvYiIsIm1lbW9pemUiLCJiaW5hcnlOYW1lIiwiZnVsbFBhdGgiLCJ3aGljaCJdLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi96aXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB5YXV6bCBmcm9tICd5YXV6bCc7XG5pbXBvcnQgYXJjaGl2ZXIgZnJvbSAnYXJjaGl2ZXInO1xuaW1wb3J0IHtjcmVhdGVXcml0ZVN0cmVhbX0gZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgZnMgZnJvbSAnLi9mcyc7XG5pbXBvcnQge2lzV2luZG93c30gZnJvbSAnLi9zeXN0ZW0nO1xuaW1wb3J0IHtCYXNlNjRFbmNvZGV9IGZyb20gJ2Jhc2U2NC1zdHJlYW0nO1xuaW1wb3J0IHt0b1JlYWRhYmxlU2l6ZVN0cmluZywgR2lCfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vdGltaW5nJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IGdldFN0cmVhbSBmcm9tICdnZXQtc3RyZWFtJztcbmltcG9ydCB7ZXhlY30gZnJvbSAndGVlbl9wcm9jZXNzJztcblxuLyoqXG4gKiBAdHlwZSB7KHBhdGg6IHN0cmluZywgb3B0aW9ucz86IHlhdXpsLk9wdGlvbnMpID0+IFByb21pc2U8eWF1emwuWmlwRmlsZT59XG4gKi9cbmNvbnN0IG9wZW5aaXAgPSBCLnByb21pc2lmeSh5YXV6bC5vcGVuKTtcbi8qKlxuICogQHR5cGUgeyhzb3VyY2U6IE5vZGVKUy5SZWFkYWJsZVN0cmVhbSwgZGVzdGluYXRpb246IE5vZGVKUy5Xcml0YWJsZVN0cmVhbSkgPT4gUHJvbWlzZTxOb2RlSlMuV3JpdGFibGVTdHJlYW0+fVxuICovXG5jb25zdCBwaXBlbGluZSA9IEIucHJvbWlzaWZ5KHN0cmVhbS5waXBlbGluZSk7XG5jb25zdCBaSVBfTUFHSUMgPSAnUEsnO1xuY29uc3QgSUZNVCA9IDYxNDQwO1xuY29uc3QgSUZESVIgPSAxNjM4NDtcbmNvbnN0IElGTE5LID0gNDA5NjA7XG5cbi8vIFRoaXMgY2xhc3MgaXMgbW9zdGx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhvZ2Rlbi9leHRyYWN0LXppcC9ibG9iL21hc3Rlci9pbmRleC5qc1xuY2xhc3MgWmlwRXh0cmFjdG9yIHtcbiAgLyoqIEB0eXBlIHt5YXV6bC5aaXBGaWxlfSAqL1xuICB6aXBmaWxlO1xuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZVBhdGgsIG9wdHMgPSB7fSkge1xuICAgIHRoaXMuemlwUGF0aCA9IHNvdXJjZVBhdGg7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG4gIH1cblxuICBleHRyYWN0RmlsZU5hbWUoZW50cnkpIHtcbiAgICByZXR1cm4gXy5pc0J1ZmZlcihlbnRyeS5maWxlTmFtZSlcbiAgICAgID8gZW50cnkuZmlsZU5hbWUudG9TdHJpbmcodGhpcy5vcHRzLmZpbGVOYW1lc0VuY29kaW5nKVxuICAgICAgOiBlbnRyeS5maWxlTmFtZTtcbiAgfVxuXG4gIGFzeW5jIGV4dHJhY3QoKSB7XG4gICAgY29uc3Qge2RpciwgZmlsZU5hbWVzRW5jb2Rpbmd9ID0gdGhpcy5vcHRzO1xuICAgIHRoaXMuemlwZmlsZSA9IGF3YWl0IG9wZW5aaXAodGhpcy56aXBQYXRoLCB7XG4gICAgICBsYXp5RW50cmllczogdHJ1ZSxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVqb3Nod29sZmUveWF1emwvY29tbWl0L2NjNzQ1NWFjNzg5YmE4NDk3MzE4NGU1ZWJkZTA1ODFjZGM0YzNiMzkjZGlmZi0wNGM2ZTkwZmFhYzI2NzVhYTg5ZTIxNzZkMmVlYzdkOFI5NVxuICAgICAgZGVjb2RlU3RyaW5nczogIWZpbGVOYW1lc0VuY29kaW5nLFxuICAgIH0pO1xuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnppcGZpbGUub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuemlwZmlsZS5yZWFkRW50cnkoKTtcblxuICAgICAgdGhpcy56aXBmaWxlLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbmNlbGVkKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy56aXBmaWxlLm9uKCdlbnRyeScsIGFzeW5jIChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5leHRyYWN0RmlsZU5hbWUoZW50cnkpO1xuICAgICAgICBpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aCgnX19NQUNPU1gvJykpIHtcbiAgICAgICAgICB0aGlzLnppcGZpbGUucmVhZEVudHJ5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVzdERpciA9IHBhdGguZGlybmFtZShwYXRoLmpvaW4oZGlyLCBmaWxlTmFtZSkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGZzLm1rZGlyKGRlc3REaXIsIHtyZWN1cnNpdmU6IHRydWV9KTtcblxuICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbERlc3REaXIgPSBhd2FpdCBmcy5yZWFscGF0aChkZXN0RGlyKTtcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZURlc3REaXIgPSBwYXRoLnJlbGF0aXZlKGRpciwgY2Fub25pY2FsRGVzdERpcik7XG5cbiAgICAgICAgICBpZiAocmVsYXRpdmVEZXN0RGlyLnNwbGl0KHBhdGguc2VwKS5pbmNsdWRlcygnLi4nKSkge1xuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgT3V0IG9mIGJvdW5kIHBhdGggXCIke2Nhbm9uaWNhbERlc3REaXJ9XCIgZm91bmQgd2hpbGUgcHJvY2Vzc2luZyBmaWxlICR7ZmlsZU5hbWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdGhpcy56aXBmaWxlLnJlYWRFbnRyeSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnppcGZpbGUuY2xvc2UoKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBleHRyYWN0RW50cnkoZW50cnkpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtkaXJ9ID0gdGhpcy5vcHRzO1xuXG4gICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmV4dHJhY3RGaWxlTmFtZShlbnRyeSk7XG4gICAgY29uc3QgZGVzdCA9IHBhdGguam9pbihkaXIsIGZpbGVOYW1lKTtcblxuICAgIC8vIGNvbnZlcnQgZXh0ZXJuYWwgZmlsZSBhdHRyIGludCBpbnRvIGEgZnMgc3RhdCBtb2RlIGludFxuICAgIGNvbnN0IG1vZGUgPSAoZW50cnkuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA+PiAxNikgJiAweGZmZmY7XG4gICAgLy8gY2hlY2sgaWYgaXQncyBhIHN5bWxpbmsgb3IgZGlyICh1c2luZyBzdGF0IG1vZGUgY29uc3RhbnRzKVxuICAgIGNvbnN0IGlzU3ltbGluayA9IChtb2RlICYgSUZNVCkgPT09IElGTE5LO1xuICAgIGNvbnN0IGlzRGlyID1cbiAgICAgIChtb2RlICYgSUZNVCkgPT09IElGRElSIHx8XG4gICAgICAvLyBGYWlsc2FmZSwgYm9ycm93ZWQgZnJvbSBqc1ppcFxuICAgICAgZmlsZU5hbWUuZW5kc1dpdGgoJy8nKSB8fFxuICAgICAgLy8gY2hlY2sgZm9yIHdpbmRvd3Mgd2VpcmQgd2F5IG9mIHNwZWNpZnlpbmcgYSBkaXJlY3RvcnlcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhvZ2Rlbi9leHRyYWN0LXppcC9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTE1NDQ5NDU2NlxuICAgICAgKGVudHJ5LnZlcnNpb25NYWRlQnkgPj4gOCA9PT0gMCAmJiBlbnRyeS5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID09PSAxNik7XG4gICAgY29uc3QgcHJvY01vZGUgPSB0aGlzLmdldEV4dHJhY3RlZE1vZGUobW9kZSwgaXNEaXIpICYgMG83Nzc7XG4gICAgLy8gYWx3YXlzIGVuc3VyZSBmb2xkZXJzIGFyZSBjcmVhdGVkXG4gICAgY29uc3QgZGVzdERpciA9IGlzRGlyID8gZGVzdCA6IHBhdGguZGlybmFtZShkZXN0KTtcbiAgICBjb25zdCBta2Rpck9wdGlvbnMgPSB7cmVjdXJzaXZlOiB0cnVlfTtcbiAgICBpZiAoaXNEaXIpIHtcbiAgICAgIG1rZGlyT3B0aW9ucy5tb2RlID0gcHJvY01vZGU7XG4gICAgfVxuICAgIGF3YWl0IGZzLm1rZGlyKGRlc3REaXIsIG1rZGlyT3B0aW9ucyk7XG4gICAgaWYgKGlzRGlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHsoZW50cnk6IHlhdXpsLkVudHJ5KSA9PiBQcm9taXNlPE5vZGVKUy5SZWFkYWJsZVN0cmVhbT59ICovXG4gICAgY29uc3Qgb3BlblJlYWRTdHJlYW0gPSBCLnByb21pc2lmeSh0aGlzLnppcGZpbGUub3BlblJlYWRTdHJlYW0uYmluZCh0aGlzLnppcGZpbGUpKTtcbiAgICBjb25zdCByZWFkU3RyZWFtID0gYXdhaXQgb3BlblJlYWRTdHJlYW0oZW50cnkpO1xuICAgIGlmIChpc1N5bWxpbmspIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBhd2FpdCBnZXRTdHJlYW0ocmVhZFN0cmVhbSk7XG4gICAgICBhd2FpdCBmcy5zeW1saW5rKGxpbmssIGRlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBwaXBlbGluZShyZWFkU3RyZWFtLCBmcy5jcmVhdGVXcml0ZVN0cmVhbShkZXN0LCB7bW9kZTogcHJvY01vZGV9KSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RXh0cmFjdGVkTW9kZShlbnRyeU1vZGUsIGlzRGlyKSB7XG4gICAgY29uc3Qge2RlZmF1bHREaXJNb2RlLCBkZWZhdWx0RmlsZU1vZGV9ID0gdGhpcy5vcHRzO1xuXG4gICAgbGV0IG1vZGUgPSBlbnRyeU1vZGU7XG4gICAgLy8gU2V0IGRlZmF1bHRzLCBpZiBuZWNlc3NhcnlcbiAgICBpZiAobW9kZSA9PT0gMCkge1xuICAgICAgaWYgKGlzRGlyKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RGlyTW9kZSkge1xuICAgICAgICAgIG1vZGUgPSBwYXJzZUludChkZWZhdWx0RGlyTW9kZSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgbW9kZSA9IDBvNzU1O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGVmYXVsdEZpbGVNb2RlKSB7XG4gICAgICAgICAgbW9kZSA9IHBhcnNlSW50KGRlZmF1bHRGaWxlTW9kZSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgbW9kZSA9IDBvNjQ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBFeHRyYWN0QWxsT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWxlTmFtZXNFbmNvZGluZ10gVGhlIGVuY29kaW5nIHRvIHVzZSBmb3IgZXh0cmFjdGVkIGZpbGUgbmFtZXMuXG4gKiBGb3IgWklQIGFyY2hpdmVzIGNyZWF0ZWQgb24gTWFjT1MgaXQgaXMgdXN1YWxseSBleHBlY3RlZCB0byBiZSBgdXRmOGAuXG4gKiBCeSBkZWZhdWx0IGl0IGlzIGF1dG9kZXRlY3RlZCBiYXNlZCBvbiB0aGUgZW50cnkgbWV0YWRhdGEgYW5kIGlzIG9ubHkgbmVlZGVkIHRvIGJlIHNldCBleHBsaWNpdGx5XG4gKiBpZiB0aGUgcGFydGljdWxhciBhcmNoaXZlIGRvZXMgbm90IGNvbXBseSB0byB0aGUgc3RhbmRhcmRzLCB3aGljaCBsZWFkcyB0byBjb3JydXB0ZWQgZmlsZSBuYW1lc1xuICogYWZ0ZXIgZXh0cmFjdGlvbi4gT25seSBhcHBsaWNhYmxlIGlmIHN5c3RlbSB1bnppcCBiaW5hcnkgaXMgTk9UIGJlaW5nIHVzZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VTeXN0ZW1VbnppcF0gSWYgdHJ1ZSwgYXR0ZW1wdCB0byB1c2Ugc3lzdGVtIHVuemlwOyBpZiB0aGlzIGZhaWxzLFxuICogZmFsbGJhY2sgdG8gdGhlIEpTIHVuemlwIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCB6aXBmaWxlIHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHppcEZpbGVQYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIHNvdXJjZSBaSVAgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3REaXIgVGhlIGZ1bGwgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyXG4gKiBAcGFyYW0ge0V4dHJhY3RBbGxPcHRpb25zfSBbb3B0c11cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEFsbFRvKHppcEZpbGVQYXRoLCBkZXN0RGlyLCBvcHRzID0gLyoqIEB0eXBlIHtFeHRyYWN0QWxsT3B0aW9uc30gKi8gKHt9KSkge1xuICBpZiAoIXBhdGguaXNBYnNvbHV0ZShkZXN0RGlyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IHBhdGggJyR7ZGVzdERpcn0nIGlzIGV4cGVjdGVkIHRvIGJlIGFic29sdXRlYCk7XG4gIH1cblxuICBhd2FpdCBmcy5ta2RpcihkZXN0RGlyLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gIGNvbnN0IGRpciA9IGF3YWl0IGZzLnJlYWxwYXRoKGRlc3REaXIpO1xuICBpZiAob3B0cy51c2VTeXN0ZW1VbnppcCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBleHRyYWN0V2l0aFN5c3RlbVVuemlwKHppcEZpbGVQYXRoLCBkaXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oJ3VuemlwIGZhaWxlZDsgZmFsbGluZyBiYWNrIHRvIEpTOiAlcycsIGVyci5zdGRlcnIgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBjb25zdCBleHRyYWN0b3IgPSBuZXcgWmlwRXh0cmFjdG9yKHppcEZpbGVQYXRoLCB7XG4gICAgLi4ub3B0cyxcbiAgICBkaXIsXG4gIH0pO1xuICBhd2FpdCBleHRyYWN0b3IuZXh0cmFjdCgpO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHN5c3RlbSB1bnppcCAoZS5nLiwgYC91c3IvYmluL3VuemlwYCkuIElmIGF2YWlsYWJsZSwgaXQgaXNcbiAqIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gdGhlIEpTIGltcGxlbWVudGF0aW9uLlxuICogQnkgZGVmYXVsdCBhbGwgZmlsZXMgaW4gdGhlIGRlc3REaXIgZ2V0IG92ZXJyaWRkZW4gaWYgYWxyZWFkeSBleGlzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIuXG4gKiBUaGlzIGZvbGRlciBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGV4aXN0IGJlZm9yZSBleHRyYWN0aW5nIHRoZSBhcmNoaXZlLlxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0V2l0aFN5c3RlbVVuemlwKHppcEZpbGVQYXRoLCBkZXN0RGlyKSB7XG4gIGNvbnN0IGlzV2luZG93c0hvc3QgPSBpc1dpbmRvd3MoKTtcbiAgbGV0IGV4ZWN1dGFibGVQYXRoO1xuICB0cnkge1xuICAgIGV4ZWN1dGFibGVQYXRoID0gYXdhaXQgZ2V0RXhlY3V0YWJsZVBhdGgoaXNXaW5kb3dzSG9zdCA/ICdwb3dlcnNoZWxsLmV4ZScgOiAndW56aXAnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgc3lzdGVtIHVuemlwJyk7XG4gIH1cblxuICBpZiAoaXNXaW5kb3dzSG9zdCkge1xuICAgIC8vIG9uIFdpbmRvd3Mgd2UgdXNlIFBvd2VyU2hlbGwgdG8gdW56aXAgZmlsZXNcbiAgICBhd2FpdCBleGVjKGV4ZWN1dGFibGVQYXRoLCBbXG4gICAgICAnLWNvbW1hbmQnLFxuICAgICAgJ0V4cGFuZC1BcmNoaXZlJyxcbiAgICAgICctTGl0ZXJhbFBhdGgnLFxuICAgICAgemlwRmlsZVBhdGgsXG4gICAgICAnLURlc3RpbmF0aW9uUGF0aCcsXG4gICAgICBkZXN0RGlyLFxuICAgICAgJy1Gb3JjZScsXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gLXEgbWVhbnMgcXVpZXQgKG5vIHN0ZG91dClcbiAgICAvLyAtbyBtZWFucyBvdmVyd3JpdGVcbiAgICAvLyAtZCBpcyB0aGUgZGVzdCBkaXJcbiAgICBhd2FpdCBleGVjKGV4ZWN1dGFibGVQYXRoLCBbJy1xJywgJy1vJywgemlwRmlsZVBhdGgsICctZCcsIGRlc3REaXJdKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBzaW5nbGUgemlwIGVudHJ5IHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHt5YXV6bC5aaXBGaWxlfSB6aXBGaWxlIFRoZSBzb3VyY2UgWklQIHN0cmVhbVxuICogQHBhcmFtIHt5YXV6bC5FbnRyeX0gZW50cnkgVGhlIGVudHJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2V4dHJhY3RFbnRyeVRvKHppcEZpbGUsIGVudHJ5LCBkZXN0RGlyKSB7XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoZGVzdERpciwgZW50cnkuZmlsZU5hbWUpO1xuXG4gIC8vIENyZWF0ZSBkZXN0IGRpcmVjdG9yeSBpZiBkb2Vzbid0IGV4aXN0IGFscmVhZHlcbiAgaWYgKC9cXC8kLy50ZXN0KGVudHJ5LmZpbGVOYW1lKSkge1xuICAgIGlmICghKGF3YWl0IGZzLmV4aXN0cyhkc3RQYXRoKSkpIHtcbiAgICAgIGF3YWl0IGZzLm1rZGlycChkc3RQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCEoYXdhaXQgZnMuZXhpc3RzKHBhdGguZGlybmFtZShkc3RQYXRoKSkpKSB7XG4gICAgYXdhaXQgZnMubWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSB3cml0ZSBzdHJlYW1cbiAgY29uc3Qgd3JpdGVTdHJlYW0gPSBjcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoLCB7ZmxhZ3M6ICd3J30pO1xuICBjb25zdCB3cml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgemlwUmVhZFN0cmVhbSBhbmQgcGlwZSBkYXRhIHRvIHRoZSB3cml0ZSBzdHJlYW1cbiAgLy8gKGZvciBzb21lIG9kZCByZWFzb24gQi5wcm9taXNpZnkgZG9lc24ndCB3b3JrIG9uIHppcGZpbGUub3BlblJlYWRTdHJlYW0sIGl0IGNhdXNlcyBhbiBlcnJvciAnY2xvc2VkJylcbiAgY29uc3QgemlwUmVhZFN0cmVhbSA9IGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBGaWxlLm9wZW5SZWFkU3RyZWFtKGVudHJ5LCAoZXJyLCByZWFkU3RyZWFtKSA9PiAoZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlYWRTdHJlYW0pKSk7XG4gIH0pO1xuICBjb25zdCB6aXBSZWFkU3RyZWFtUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBSZWFkU3RyZWFtLm9uY2UoJ2VuZCcsIHJlc29sdmUpO1xuICAgIHppcFJlYWRTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICB9KTtcbiAgemlwUmVhZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcblxuICAvLyBXYWl0IGZvciB0aGUgemlwUmVhZFN0cmVhbSBhbmQgd3JpdGVTdHJlYW0gdG8gZW5kIGJlZm9yZSByZXR1cm5pbmdcbiAgcmV0dXJuIGF3YWl0IEIuYWxsKFt6aXBSZWFkU3RyZWFtUHJvbWlzZSwgd3JpdGVTdHJlYW1Qcm9taXNlXSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgWmlwRW50cnlcbiAqIEBwcm9wZXJ0eSB7eWF1emwuRW50cnl9IGVudHJ5IFRoZSBhY3R1YWwgZW50cnkgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGV4dHJhY3RFbnRyeVRvIEFuIGFzeW5jIGZ1bmN0aW9uLCB3aGljaCBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuXG4gKiBUaGlzIHBhcmFtZXRlciBjb250YWlucyB0aGUgZGVzdGluYXRpb24gZm9sZGVyIHBhdGggdG8gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBnb2luZyB0byBleHRyYWN0IHRoZSBlbnRyeS5cbiAqL1xuXG4vKipcbiAqIEdldCBlbnRyaWVzIGZvciBhIHppcCBmb2xkZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkVudHJ5IENhbGxiYWNrIHdoZW4gZW50cnkgaXMgcmVhZC5cbiAqIFRoZSBjYWxsYmFjayBpcyBleHBlY3RlZCB0byBhY2NlcHQgb25lIGFyZ3VtZW50IG9mIFppcEVudHJ5IHR5cGUuXG4gKiBUaGUgaXRlcmF0aW9uIHRocm91Z2ggdGhlIHNvdXJjZSB6aXAgZmlsZSB3aWxsIGJpIHRlcm1pbmF0ZWQgYXMgc29vbiBhc1xuICogdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGVxdWFscyB0byBgZmFsc2VgLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkRW50cmllcyh6aXBGaWxlUGF0aCwgb25FbnRyeSkge1xuICAvLyBPcGVuIGEgemlwIGZpbGUgYW5kIHN0YXJ0IHJlYWRpbmcgZW50cmllc1xuICBjb25zdCB6aXBmaWxlID0gYXdhaXQgb3BlblppcCh6aXBGaWxlUGF0aCwge2xhenlFbnRyaWVzOiB0cnVlfSk7XG4gIGNvbnN0IHppcFJlYWRTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcGZpbGUub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgemlwZmlsZS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICAvLyBPbiBlYWNoIGVudHJ5LCBjYWxsICdvbkVudHJ5JyBhbmQgdGhlbiByZWFkIHRoZSBuZXh0IGVudHJ5XG4gICAgemlwZmlsZS5vbignZW50cnknLCBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9uRW50cnkoe1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgZXh0cmFjdEVudHJ5VG86IGFzeW5jIChkZXN0RGlyKSA9PiBhd2FpdCBfZXh0cmFjdEVudHJ5VG8oemlwZmlsZSwgZW50cnksIGRlc3REaXIpLFxuICAgICAgfSk7XG4gICAgICBpZiAocmVzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gemlwZmlsZS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XG4gICAgfSk7XG4gIH0pO1xuICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSBlbnRyaWVzIHRvIGZpbmlzaCBiZWluZyBpdGVyYXRlZCB0aHJvdWdoXG4gIHJldHVybiBhd2FpdCB6aXBSZWFkU3RyZWFtUHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBaaXBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuY29kZVRvQmFzZTY0IFtmYWxzZV0gV2hldGhlciB0byBlbmNvZGVcbiAqIHRoZSByZXN1bHRpbmcgYXJjaGl2ZSB0byBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc01ldGVyZWQgW3RydWVdIFdoZXRoZXIgdG8gbG9nIHRoZSBhY3R1YWxcbiAqIGFyY2hpdmVyIHBlcmZvcm1hbmNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4U2l6ZSBbMTA3Mzc0MTgyNF0gVGhlIG1heGltdW0gc2l6ZSBvZlxuICogdGhlIHJlc3VsdGluZyBhcmNoaXZlIGluIGJ5dGVzLiBUaGlzIGlzIHNldCB0byAxR0IgYnkgZGVmYXVsdCwgYmVjYXVzZVxuICogQXBwaXVtIGxpbWl0cyB0aGUgbWF4aW11bSBIVFRQIGJvZHkgc2l6ZSB0byAxR0IuIEFsc28sIHRoZSBOb2RlSlMgaGVhcFxuICogc2l6ZSBtdXN0IGJlIGVub3VnaCB0byBrZWVwIHRoZSByZXN1bHRpbmcgb2JqZWN0ICh1c3VhbGx5IHRoaXMgc2l6ZSBpc1xuICogbGltaXRlZCB0byAxLjQgR0IpXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGV2ZWwgWzldIFRoZSBjb21wcmVzc2lvbiBsZXZlbC4gVGhlIG1heGltdW1cbiAqIGxldmVsIGlzIDkgKHRoZSBiZXN0IGNvbXByZXNzaW9uLCB3b3JzdCBwZXJmb3JtYW5jZSkuIFRoZSBtaW5pbXVtXG4gKiBjb21wcmVzc2lvbiBsZXZlbCBpcyAwIChubyBjb21wcmVzc2lvbikuXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBjb250ZW50cyBvZiBsb2NhbCBkaXJlY3RvcnkgdG8gYW4gaW4tbWVtb3J5IC56aXAgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY1BhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgZm9sZGVyIG9yIGZpbGUgYmVpbmcgemlwcGVkXG4gKiBAcGFyYW0ge1ppcE9wdGlvbnN9IG9wdHMgWmlwcGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBaaXBwZWQgKGFuZCBlbmNvZGVkIGlmIGBlbmNvZGVUb0Jhc2U2NGAgaXMgdHJ1dGh5KVxuICogY29udGVudCBvZiB0aGUgc291cmNlIHBhdGggYXMgbWVtb3J5IGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSByZWFkaW5nIHRoZSBzb3VyY2VcbiAqIG9yIHRoZSBzb3VyY2UgaXMgdG9vIGJpZ1xuICovXG5hc3luYyBmdW5jdGlvbiB0b0luTWVtb3J5WmlwKHNyY1BhdGgsIG9wdHMgPSAvKiogQHR5cGUge1ppcE9wdGlvbnN9ICovICh7fSkpIHtcbiAgaWYgKCEoYXdhaXQgZnMuZXhpc3RzKHNyY1BhdGgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCBmaWxlIG9yIGZvbGRlcjogJHtzcmNQYXRofWApO1xuICB9XG5cbiAgY29uc3Qge2lzTWV0ZXJlZCA9IHRydWUsIGVuY29kZVRvQmFzZTY0ID0gZmFsc2UsIG1heFNpemUgPSAxICogR2lCLCBsZXZlbCA9IDl9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0QnVmZmVycyA9IFtdO1xuICBsZXQgcmVzdWx0QnVmZmVyc1NpemUgPSAwO1xuICAvLyBDcmVhdGUgYSB3cml0YWJsZSBzdHJlYW0gdGhhdCB6aXAgYnVmZmVycyB3aWxsIGJlIHN0cmVhbWVkIHRvXG4gIGNvbnN0IHJlc3VsdFdyaXRlU3RyZWFtID0gbmV3IHN0cmVhbS5Xcml0YWJsZSh7XG4gICAgd3JpdGU6IChidWZmZXIsIGVuY29kaW5nLCBuZXh0KSA9PiB7XG4gICAgICByZXN1bHRCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgIHJlc3VsdEJ1ZmZlcnNTaXplICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICBpZiAobWF4U2l6ZSA+IDAgJiYgcmVzdWx0QnVmZmVyc1NpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHJlc3VsdFdyaXRlU3RyZWFtLmVtaXQoXG4gICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyBgICtcbiAgICAgICAgICAgICAgYGFyY2hpdmUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuICR7dG9SZWFkYWJsZVNpemVTdHJpbmcobWF4U2l6ZSl9YFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG5leHQoKTtcbiAgICB9LFxuICB9KTtcblxuICAvLyBaaXAgJ3NyY0RpcicgYW5kIHN0cmVhbSBpdCB0byB0aGUgYWJvdmUgd3JpdGFibGUgc3RyZWFtXG4gIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJywge1xuICAgIHpsaWI6IHtsZXZlbH0sXG4gIH0pO1xuICBsZXQgc3JjU2l6ZSA9IG51bGw7XG4gIGNvbnN0IGJhc2U2NEVuY29kZXJTdHJlYW0gPSBlbmNvZGVUb0Jhc2U2NCA/IG5ldyBCYXNlNjRFbmNvZGUoKSA6IG51bGw7XG4gIGNvbnN0IHJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXN1bHRXcml0ZVN0cmVhbS5vbmNlKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICBpZiAoYmFzZTY0RW5jb2RlclN0cmVhbSkge1xuICAgICAgICBhcmNoaXZlLnVucGlwZShiYXNlNjRFbmNvZGVyU3RyZWFtKTtcbiAgICAgICAgYmFzZTY0RW5jb2RlclN0cmVhbS51bnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJjaGl2ZS51bnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICAgICAgfVxuICAgICAgYXJjaGl2ZS5hYm9ydCgpO1xuICAgICAgYXJjaGl2ZS5kZXN0cm95KCk7XG4gICAgICByZWplY3QoZSk7XG4gICAgfSk7XG4gICAgcmVzdWx0V3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgKCkgPT4ge1xuICAgICAgc3JjU2l6ZSA9IGFyY2hpdmUucG9pbnRlcigpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgYXJjaGl2ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXJjaGl2ZS5vbmNlKCdmaW5pc2gnLCByZXNvbHZlKTtcbiAgICBhcmNoaXZlLm9uY2UoJ2Vycm9yJywgKGUpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBhcmNoaXZlICcke3NyY1BhdGh9JzogJHtlLm1lc3NhZ2V9YCkpKTtcbiAgfSk7XG4gIGNvbnN0IHRpbWVyID0gaXNNZXRlcmVkID8gbmV3IFRpbWVyKCkuc3RhcnQoKSA6IG51bGw7XG4gIGlmICgoYXdhaXQgZnMuc3RhdChzcmNQYXRoKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgIGFyY2hpdmUuZGlyZWN0b3J5KHNyY1BhdGgsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBhcmNoaXZlLmZpbGUoc3JjUGF0aCwge1xuICAgICAgbmFtZTogcGF0aC5iYXNlbmFtZShzcmNQYXRoKSxcbiAgICB9KTtcbiAgfVxuICBpZiAoYmFzZTY0RW5jb2RlclN0cmVhbSkge1xuICAgIGFyY2hpdmUucGlwZShiYXNlNjRFbmNvZGVyU3RyZWFtKTtcbiAgICBiYXNlNjRFbmNvZGVyU3RyZWFtLnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIGFyY2hpdmUucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gIH1cbiAgYXJjaGl2ZS5maW5hbGl6ZSgpO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSBzdHJlYW1zIHRvIGZpbmlzaFxuICBhd2FpdCBCLmFsbChbYXJjaGl2ZVN0cmVhbVByb21pc2UsIHJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZV0pO1xuXG4gIGlmICh0aW1lcikge1xuICAgIGxvZy5kZWJ1ZyhcbiAgICAgIGBaaXBwZWQgJHtlbmNvZGVUb0Jhc2U2NCA/ICdhbmQgYmFzZTY0LWVuY29kZWQgJyA6ICcnfWAgK1xuICAgICAgICBgJyR7cGF0aC5iYXNlbmFtZShzcmNQYXRoKX0nIGAgK1xuICAgICAgICAoc3JjU2l6ZSA/IGAoJHt0b1JlYWRhYmxlU2l6ZVN0cmluZyhzcmNTaXplKX0pIGAgOiAnJykgK1xuICAgICAgICBgaW4gJHt0aW1lci5nZXREdXJhdGlvbigpLmFzU2Vjb25kcy50b0ZpeGVkKDMpfXMgYCArXG4gICAgICAgIGAoY29tcHJlc3Npb24gbGV2ZWw6ICR7bGV2ZWx9KWBcbiAgICApO1xuICB9XG4gIC8vIFJldHVybiB0aGUgYXJyYXkgb2YgemlwIGJ1ZmZlcnMgY29uY2F0ZW5hdGVkIGludG8gb25lIGJ1ZmZlclxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChyZXN1bHRCdWZmZXJzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB3aGV0aGVyIHRoZSBnaXZlbiBmaWxlIGlzIGEgdmFsaWQgWklQIGFyY2hpdmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggLSBGdWxsIHBhdGggdG8gdGhlIGZpbGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICovXG5hc3luYyBmdW5jdGlvbiBhc3NlcnRWYWxpZFppcChmaWxlUGF0aCkge1xuICBpZiAoIShhd2FpdCBmcy5leGlzdHMoZmlsZVBhdGgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpbGUgYXQgJyR7ZmlsZVBhdGh9JyBkb2VzIG5vdCBleGlzdGApO1xuICB9XG5cbiAgY29uc3Qge3NpemV9ID0gYXdhaXQgZnMuc3RhdChmaWxlUGF0aCk7XG4gIGlmIChzaXplIDwgNCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpbGUgYXQgJyR7ZmlsZVBhdGh9JyBpcyB0b28gc21hbGwgdG8gYmUgYSBaSVAgYXJjaGl2ZWApO1xuICB9XG4gIGNvbnN0IGZkID0gYXdhaXQgZnMub3BlbihmaWxlUGF0aCwgJ3InKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoWklQX01BR0lDLmxlbmd0aCk7XG4gICAgYXdhaXQgZnMucmVhZChmZCwgYnVmZmVyLCAwLCBaSVBfTUFHSUMubGVuZ3RoLCAwKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBidWZmZXIudG9TdHJpbmcoJ2FzY2lpJyk7XG4gICAgaWYgKHNpZ25hdHVyZSAhPT0gWklQX01BR0lDKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgZmlsZSBzaWduYXR1cmUgJyR7c2lnbmF0dXJlfScgb2YgJyR7ZmlsZVBhdGh9JyBgICtcbiAgICAgICAgICBgaXMgbm90IGVxdWFsIHRvIHRoZSBleHBlY3RlZCBaSVAgYXJjaGl2ZSBzaWduYXR1cmUgJyR7WklQX01BR0lDfSdgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5jbG9zZShmZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBaaXBDb21wcmVzc2lvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbCBbOV0gLSBDb21wcmVzc2lvbiBsZXZlbCBpbiByYW5nZSAwLi45XG4gKiAoZ3JlYXRlciBudW1iZXJzIG1lYW4gYmV0dGVyIGNvbXByZXNzaW9uLCBidXQgbG9uZ2VyIHByb2Nlc3NpbmcgdGltZSlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFppcFNvdXJjZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXR0ZXJuIFsnKipcXC8qJ10gLSBHTE9CIHBhdHRlcm4gZm9yIGNvbXByZXNzaW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY3dkIC0gVGhlIHNvdXJjZSByb290IGZvbGRlciAodGhlIHBhcmVudCBmb2xkZXIgb2ZcbiAqIHRoZSBkZXN0aW5hdGlvbiBmaWxlIGJ5IGRlZmF1bHQpXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbaWdub3JlXSAtIFRoZSBsaXN0IG9mIGlnbm9yZWQgcGF0dGVybnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJjaGl2ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZ2xvYiBwYXR0ZXJuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRzdFBhdGggLSBUaGUgcmVzdWx0aW5nIGFyY2hpdmUgcGF0aFxuICogQHBhcmFtIHtaaXBTb3VyY2VPcHRpb25zfSBzcmMgLSBTb3VyY2Ugb3B0aW9uc1xuICogQHBhcmFtIHtaaXBDb21wcmVzc2lvbk9wdGlvbnN9IG9wdHMgLSBDb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBhcmNoaXZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRvQXJjaGl2ZShcbiAgZHN0UGF0aCxcbiAgc3JjID0gLyoqIEB0eXBlIHtaaXBTb3VyY2VPcHRpb25zfSAqLyAoe30pLFxuICBvcHRzID0gLyoqIEB0eXBlIHtaaXBDb21wcmVzc2lvbk9wdGlvbnN9ICovICh7fSlcbikge1xuICBjb25zdCB7bGV2ZWwgPSA5fSA9IG9wdHM7XG4gIGNvbnN0IHtwYXR0ZXJuID0gJyoqLyonLCBjd2QgPSBwYXRoLmRpcm5hbWUoZHN0UGF0aCksIGlnbm9yZSA9IFtdfSA9IHNyYztcbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7emxpYjoge2xldmVsfX0pO1xuICBjb25zdCBzdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhcmNoaXZlXG4gICAgICAuZ2xvYihwYXR0ZXJuLCB7XG4gICAgICAgIGN3ZCxcbiAgICAgICAgaWdub3JlLFxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAucGlwZShzdHJlYW0pO1xuICAgIHN0cmVhbVxuICAgICAgLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKHN0cmVhbSk7XG4gICAgICAgIGFyY2hpdmUuYWJvcnQoKTtcbiAgICAgICAgYXJjaGl2ZS5kZXN0cm95KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pXG4gICAgICAub24oJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgIGFyY2hpdmUuZmluYWxpemUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRmluZHMgYW5kIG1lbW9pemVzIHRoZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGV4ZWN1dGFibGUuXG4gKiBSZWplY3RzIGlmIGl0IGlzIG5vdCBmb3VuZC5cbiAqL1xuY29uc3QgZ2V0RXhlY3V0YWJsZVBhdGggPSBfLm1lbW9pemUoXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBGdWxsIFBhdGggdG8gdGhlIGV4ZWN1dGFibGVcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEV4ZWN1dGFibGVQYXRoKGJpbmFyeU5hbWUpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IGF3YWl0IGZzLndoaWNoKGJpbmFyeU5hbWUpO1xuICAgIGxvZy5kZWJ1ZyhgRm91bmQgJyVzJyBhdCAnJXMnYCwgYmluYXJ5TmFtZSwgZnVsbFBhdGgpO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuKTtcblxuZXhwb3J0IHtleHRyYWN0QWxsVG8sIHJlYWRFbnRyaWVzLCB0b0luTWVtb3J5WmlwLCBfZXh0cmFjdEVudHJ5VG8sIGFzc2VydFZhbGlkWmlwLCB0b0FyY2hpdmV9O1xuZXhwb3J0IGRlZmF1bHQge1xuICBleHRyYWN0QWxsVG8sXG4gIHJlYWRFbnRyaWVzLFxuICB0b0luTWVtb3J5WmlwLFxuICBhc3NlcnRWYWxpZFppcCxcbiAgdG9BcmNoaXZlLFxufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFLQSxNQUFNQSxPQUFPLEdBQUdDLGlCQUFBLENBQUVDLFNBQUYsQ0FBWUMsY0FBQSxDQUFNQyxJQUFsQixDQUFoQjs7QUFJQSxNQUFNQyxRQUFRLEdBQUdKLGlCQUFBLENBQUVDLFNBQUYsQ0FBWUksZUFBQSxDQUFPRCxRQUFuQixDQUFqQjs7QUFDQSxNQUFNRSxTQUFTLEdBQUcsSUFBbEI7QUFDQSxNQUFNQyxJQUFJLEdBQUcsS0FBYjtBQUNBLE1BQU1DLEtBQUssR0FBRyxLQUFkO0FBQ0EsTUFBTUMsS0FBSyxHQUFHLEtBQWQ7O0FBR0EsTUFBTUMsWUFBTixDQUFtQjtFQUVqQkMsT0FBTzs7RUFFUEMsV0FBVyxDQUFDQyxVQUFELEVBQWFDLElBQUksR0FBRyxFQUFwQixFQUF3QjtJQUNqQyxLQUFLQyxPQUFMLEdBQWVGLFVBQWY7SUFDQSxLQUFLQyxJQUFMLEdBQVlBLElBQVo7SUFDQSxLQUFLRSxRQUFMLEdBQWdCLEtBQWhCO0VBQ0Q7O0VBRURDLGVBQWUsQ0FBQ0MsS0FBRCxFQUFRO0lBQ3JCLE9BQU9DLGVBQUEsQ0FBRUMsUUFBRixDQUFXRixLQUFLLENBQUNHLFFBQWpCLElBQ0hILEtBQUssQ0FB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