"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _support = require("@appium/support");

var _path = _interopRequireDefault(require("path"));

var _appiumIosDevice = require("appium-ios-device");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _logger = _interopRequireDefault(require("./logger"));

var _lodash = _interopRequireDefault(require("lodash"));

var _teen_process = require("teen_process");

var _appUtils = require("./app-utils");

var _iosFsHelpers = require("./ios-fs-helpers");

const APPLICATION_INSTALLED_NOTIFICATION = 'com.apple.mobile.application_installed';
const INSTALLATION_STAGING_DIR = 'PublicStaging';
const APPLICATION_NOTIFICATION_TIMEOUT_MS = 30 * 1000;
const IOS_DEPLOY_TIMEOUT_MS = 4 * 60 * 1000;
const IOS_DEPLOY = 'ios-deploy';
const APP_INSTALL_STRATEGY = Object.freeze({
  SERIAL: 'serial',
  PARALLEL: 'parallel',
  IOS_DEPLOY
});

class IOSDeploy {
  constructor(udid) {
    this.udid = udid;
  }

  async remove(bundleId) {
    const service = await _appiumIosDevice.services.startInstallationProxyService(this.udid);

    try {
      await service.uninstallApplication(bundleId);
    } finally {
      service.close();
    }
  }

  async removeApp(bundleId) {
    await this.remove(bundleId);
  }

  async install(app, timeout, strategy = null) {
    if (strategy && !_lodash.default.values(APP_INSTALL_STRATEGY).includes(_lodash.default.toLower(strategy))) {
      throw new Error(`App installation strategy '${strategy}' is unknown. ` + `Only the following strategies are supported: ${_lodash.default.values(APP_INSTALL_STRATEGY)}`);
    }

    _logger.default.debug(`Using '${strategy !== null && strategy !== void 0 ? strategy : APP_INSTALL_STRATEGY.SERIAL}' app deployment strategy. ` + `You could change it by providing another value to the 'appInstallStrategy' capability`);

    const installWithIosDeploy = async () => {
      try {
        await _support.fs.which(IOS_DEPLOY);
      } catch (err) {
        throw new Error(`'${IOS_DEPLOY}' utility has not been found in PATH. Is it installed?`);
      }

      try {
        await (0, _teen_process.exec)(IOS_DEPLOY, ['--id', this.udid, '--bundle', app], {
          timeout: timeout !== null && timeout !== void 0 ? timeout : IOS_DEPLOY_TIMEOUT_MS
        });
      } catch (err) {
        throw new Error(err.stderr || err.stdout || err.message);
      }
    };

    const timer = new _support.timing.Timer().start();

    if (_lodash.default.toLower(strategy) === APP_INSTALL_STRATEGY.IOS_DEPLOY) {
      await installWithIosDeploy();
    } else {
      const afcService = await _appiumIosDevice.services.startAfcService(this.udid);

      try {
        const bundleId = await (0, _appUtils.extractBundleId)(app);

        const bundlePathOnPhone = _path.default.join(INSTALLATION_STAGING_DIR, bundleId);

        await (0, _iosFsHelpers.pushFolder)(afcService, app, bundlePathOnPhone, {
          timeoutMs: timeout,
          enableParallelPush: _lodash.default.toLower(strategy) === APP_INSTALL_STRATEGY.PARALLEL
        });
        await this.installOrUpgradeApplication(bundlePathOnPhone, await this.isAppInstalled(bundleId));
      } catch (err) {
        _logger.default.warn(`Error installing app '${app}': ${err.message}`);

        if (err instanceof _bluebird.default.TimeoutError) {
          _logger.default.warn(`Consider increasing the value of 'appPushTimeout' capability`);
        }

        _logger.default.warn(`Falling back to '${IOS_DEPLOY}' usage`);

        try {
          await installWithIosDeploy();
        } catch (err1) {
          throw new Error(`Could not install '${app}':\n` + `  - ${err.message}\n` + `  - ${err1.message}`);
        }
      } finally {
        afcService.close();
      }
    }

    _logger.default.info(`App installation succeeded after ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
  }

  async installOrUpgradeApplication(bundlePathOnPhone, isUpgrade = false) {
    const notificationService = await _appiumIosDevice.services.startNotificationProxyService(this.udid);
    const installationService = await _appiumIosDevice.services.startInstallationProxyService(this.udid);
    const appInstalledNotification = new _bluebird.default(resolve => {
      notificationService.observeNotification(APPLICATION_INSTALLED_NOTIFICATION, {
        notification: resolve
      });
    });
    const clientOptions = {
      PackageType: 'Developer'
    };

    try {
      if (isUpgrade) {
        _logger.default.debug(`An upgrade of the existing application is going to be performed`);

        await installationService.upgradeApplication(bundlePathOnPhone, clientOptions);
      } else {
        _logger.default.debug(`A new application installation is going to be performed`);

        await installationService.installApplication(bundlePathOnPhone, clientOptions);
      }

      try {
        await appInstalledNotification.timeout(APPLICATION_NOTIFICATION_TIMEOUT_MS, `Could not get the application installed notification within ` + `${APPLICATION_NOTIFICATION_TIMEOUT_MS}ms but we will continue`);
      } catch (e) {
        _logger.default.warn(`Failed to receive the notification. Error: ${e.message}`);
      }
    } finally {
      installationService.close();
      notificationService.close();
    }
  }

  async installApp(...args) {
    return await this.install(...args);
  }

  async isAppInstalled(bundleId) {
    const service = await _appiumIosDevice.services.startInstallationProxyService(this.udid);

    try {
      const applications = await service.lookupApplications({
        bundleIds: bundleId
      });
      return !!applications[bundleId];
    } finally {
      service.close();
    }
  }

  async terminateApp(bundleId) {
    let instrumentService;
    let installProxyService;

    try {
      installProxyService = await _appiumIosDevice.services.startInstallationProxyService(this.udid);
      const apps = await installProxyService.listApplications();

      if (!apps[bundleId]) {
        _logger.default.info(`The bundle id '${bundleId}' did not exist`);

        return false;
      }

      const executableName = apps[bundleId].CFBundleExecutable;

      _logger.default.debug(`The executable name for the bundle id '${bundleId}' was '${executableName}'`);

      instrumentService = await _appiumIosDevice.services.startInstrumentService(this.udid);
      const processes = await instrumentService.callChannel(_appiumIosDevice.INSTRUMENT_CHANNEL.DEVICE_INFO, 'runningProcesses');
      const process = processes.selector.find(process => process.name === executableName);

      if (!process) {
        _logger.default.info(`The process of the bundle id '${bundleId}' was not running`);

        return false;
      }

      await instrumentService.callChannel(_appiumIosDevice.INSTRUMENT_CHANNEL.PROCESS_CONTROL, 'killPid:', `${process.pid}`);
      return true;
    } catch (err) {
      _logger.default.warn(`Failed to kill '${bundleId}'. Original error: ${err.stderr || err.message}`);

      return false;
    } finally {
      if (installProxyService) {
        installProxyService.close();
      }

      if (instrumentService) {
        instrumentService.close();
      }
    }
  }

  async getUserInstalledBundleIdsByBundleName(bundleName) {
    const service = await _appiumIosDevice.services.startInstallationProxyService(this.udid);

    try {
      const applications = await service.listApplications({
        applicationType: 'User'
      });
      return _lodash.default.reduce(applications, (acc, {
        CFBundleName
      }, key) => {
        if (CFBundleName === bundleName) {
          acc.push(key);
        }

        return acc;
      }, []);
    } finally {
      service.close();
    }
  }

  async getPlatformVersion() {
    return await _appiumIosDevice.utilities.getOSVersion(this.udid);
  }

}

var _default = IOSDeploy;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL2lvcy1kZXBsb3kuanMiLCJuYW1lcyI6WyJBUFBMSUNBVElPTl9JTlNUQUxMRURfTk9USUZJQ0FUSU9OIiwiSU5TVEFMTEFUSU9OX1NUQUdJTkdfRElSIiwiQVBQTElDQVRJT05fTk9USUZJQ0FUSU9OX1RJTUVPVVRfTVMiLCJJT1NfREVQTE9ZX1RJTUVPVVRfTVMiLCJJT1NfREVQTE9ZIiwiQVBQX0lOU1RBTExfU1RSQVRFR1kiLCJPYmplY3QiLCJmcmVlemUiLCJTRVJJQUwiLCJQQVJBTExFTCIsIklPU0RlcGxveSIsImNvbnN0cnVjdG9yIiwidWRpZCIsInJlbW92ZSIsImJ1bmRsZUlkIiwic2VydmljZSIsInNlcnZpY2VzIiwic3RhcnRJbnN0YWxsYXRpb25Qcm94eVNlcnZpY2UiLCJ1bmluc3RhbGxBcHBsaWNhdGlvbiIsImNsb3NlIiwicmVtb3ZlQXBwIiwiaW5zdGFsbCIsImFwcCIsInRpbWVvdXQiLCJzdHJhdGVneSIsIl8iLCJ2YWx1ZXMiLCJpbmNsdWRlcyIsInRvTG93ZXIiLCJFcnJvciIsImxvZyIsImRlYnVnIiwiaW5zdGFsbFdpdGhJb3NEZXBsb3kiLCJmcyIsIndoaWNoIiwiZXJyIiwiZXhlYyIsInN0ZGVyciIsInN0ZG91dCIsIm1lc3NhZ2UiLCJ0aW1lciIsInRpbWluZyIsIlRpbWVyIiwic3RhcnQiLCJhZmNTZXJ2aWNlIiwic3RhcnRBZmNTZXJ2aWNlIiwiZXh0cmFjdEJ1bmRsZUlkIiwiYnVuZGxlUGF0aE9uUGhvbmUiLCJwYXRoIiwiam9pbiIsInB1c2hGb2xkZXIiLCJ0aW1lb3V0TXMiLCJlbmFibGVQYXJhbGxlbFB1c2giLCJpbnN0YWxsT3JVcGdyYWRlQXBwbGljYXRpb24iLCJpc0FwcEluc3RhbGxlZCIsIndhcm4iLCJCIiwiVGltZW91dEVycm9yIiwiZXJyMSIsImluZm8iLCJnZXREdXJhdGlvbiIsImFzTWlsbGlTZWNvbmRzIiwidG9GaXhlZCIsImlzVXBncmFkZSIsIm5vdGlmaWNhdGlvblNlcnZpY2UiLCJzdGFydE5vdGlmaWNhdGlvblByb3h5U2VydmljZSIsImluc3RhbGxhdGlvblNlcnZpY2UiLCJhcHBJbnN0YWxsZWROb3RpZmljYXRpb24iLCJyZXNvbHZlIiwib2JzZXJ2ZU5vdGlmaWNhdGlvbiIsIm5vdGlmaWNhdGlvbiIsImNsaWVudE9wdGlvbnMiLCJQYWNrYWdlVHlwZSIsInVwZ3JhZGVBcHBsaWNhdGlvbiIsImluc3RhbGxBcHBsaWNhdGlvbiIsImUiLCJpbnN0YWxsQXBwIiwiYXJncyIsImFwcGxpY2F0aW9ucyIsImxvb2t1cEFwcGxpY2F0aW9ucyIsImJ1bmRsZUlkcyIsInRlcm1pbmF0ZUFwcCIsImluc3RydW1lbnRTZXJ2aWNlIiwiaW5zdGFsbFByb3h5U2VydmljZSIsImFwcHMiLCJsaXN0QXBwbGljYXRpb25zIiwiZXhlY3V0YWJsZU5hbWUiLCJDRkJ1bmRsZUV4ZWN1dGFibGUiLCJzdGFydEluc3RydW1lbnRTZXJ2aWNlIiwicHJvY2Vzc2VzIiwiY2FsbENoYW5uZWwiLCJJTlNUUlVNRU5UX0NIQU5ORUwiLCJERVZJQ0VfSU5GTyIsInByb2Nlc3MiLCJzZWxlY3RvciIsImZpbmQiLCJuYW1lIiwiUFJPQ0VTU19DT05UUk9MIiwicGlkIiwiZ2V0VXNlckluc3RhbGxlZEJ1bmRsZUlkc0J5QnVuZGxlTmFtZSIsImJ1bmRsZU5hbWUiLCJhcHBsaWNhdGlvblR5cGUiLCJyZWR1Y2UiLCJhY2MiLCJDRkJ1bmRsZU5hbWUiLCJrZXkiLCJwdXNoIiwiZ2V0UGxhdGZvcm1WZXJzaW9uIiwidXRpbGl0aWVzIiwiZ2V0T1NWZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIuLi8uLiIsInNvdXJjZXMiOlsibGliL2lvcy1kZXBsb3kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnMsIHRpbWluZyB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHNlcnZpY2VzLCB1dGlsaXRpZXMsIElOU1RSVU1FTlRfQ0hBTk5FTCB9IGZyb20gJ2FwcGl1bS1pb3MtZGV2aWNlJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgZXh0cmFjdEJ1bmRsZUlkIH0gZnJvbSAnLi9hcHAtdXRpbHMnO1xuaW1wb3J0IHsgcHVzaEZvbGRlciB9IGZyb20gJy4vaW9zLWZzLWhlbHBlcnMnO1xuXG5jb25zdCBBUFBMSUNBVElPTl9JTlNUQUxMRURfTk9USUZJQ0FUSU9OID0gJ2NvbS5hcHBsZS5tb2JpbGUuYXBwbGljYXRpb25faW5zdGFsbGVkJztcbmNvbnN0IElOU1RBTExBVElPTl9TVEFHSU5HX0RJUiA9ICdQdWJsaWNTdGFnaW5nJztcbmNvbnN0IEFQUExJQ0FUSU9OX05PVElGSUNBVElPTl9USU1FT1VUX01TID0gMzAgKiAxMDAwO1xuY29uc3QgSU9TX0RFUExPWV9USU1FT1VUX01TID0gNCAqIDYwICogMTAwMDtcbmNvbnN0IElPU19ERVBMT1kgPSAnaW9zLWRlcGxveSc7XG5jb25zdCBBUFBfSU5TVEFMTF9TVFJBVEVHWSA9IE9iamVjdC5mcmVlemUoe1xuICBTRVJJQUw6ICdzZXJpYWwnLFxuICBQQVJBTExFTDogJ3BhcmFsbGVsJyxcbiAgSU9TX0RFUExPWSxcbn0pO1xuXG5cbmNsYXNzIElPU0RlcGxveSB7XG5cbiAgY29uc3RydWN0b3IgKHVkaWQpIHtcbiAgICB0aGlzLnVkaWQgPSB1ZGlkO1xuICB9XG5cbiAgYXN5bmMgcmVtb3ZlIChidW5kbGVJZCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEluc3RhbGxhdGlvblByb3h5U2VydmljZSh0aGlzLnVkaWQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzZXJ2aWNlLnVuaW5zdGFsbEFwcGxpY2F0aW9uKGJ1bmRsZUlkKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2VydmljZS5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlbW92ZUFwcCAoYnVuZGxlSWQpIHtcbiAgICBhd2FpdCB0aGlzLnJlbW92ZShidW5kbGVJZCk7XG4gIH1cblxuICBhc3luYyBpbnN0YWxsIChhcHAsIHRpbWVvdXQsIHN0cmF0ZWd5ID0gbnVsbCkge1xuICAgIGlmIChzdHJhdGVneSAmJiAhXy52YWx1ZXMoQVBQX0lOU1RBTExfU1RSQVRFR1kpLmluY2x1ZGVzKF8udG9Mb3dlcihzdHJhdGVneSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFwcCBpbnN0YWxsYXRpb24gc3RyYXRlZ3kgJyR7c3RyYXRlZ3l9JyBpcyB1bmtub3duLiBgICtcbiAgICAgICAgYE9ubHkgdGhlIGZvbGxvd2luZyBzdHJhdGVnaWVzIGFyZSBzdXBwb3J0ZWQ6ICR7Xy52YWx1ZXMoQVBQX0lOU1RBTExfU1RSQVRFR1kpfWApO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYFVzaW5nICcke3N0cmF0ZWd5ID8/IEFQUF9JTlNUQUxMX1NUUkFURUdZLlNFUklBTH0nIGFwcCBkZXBsb3ltZW50IHN0cmF0ZWd5LiBgICtcbiAgICAgIGBZb3UgY291bGQgY2hhbmdlIGl0IGJ5IHByb3ZpZGluZyBhbm90aGVyIHZhbHVlIHRvIHRoZSAnYXBwSW5zdGFsbFN0cmF0ZWd5JyBjYXBhYmlsaXR5YCk7XG5cbiAgICBjb25zdCBpbnN0YWxsV2l0aElvc0RlcGxveSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZzLndoaWNoKElPU19ERVBMT1kpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7SU9TX0RFUExPWX0nIHV0aWxpdHkgaGFzIG5vdCBiZWVuIGZvdW5kIGluIFBBVEguIElzIGl0IGluc3RhbGxlZD9gKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGV4ZWMoSU9TX0RFUExPWSwgW1xuICAgICAgICAgICctLWlkJywgdGhpcy51ZGlkLFxuICAgICAgICAgICctLWJ1bmRsZScsIGFwcCxcbiAgICAgICAgXSwge3RpbWVvdXQ6IHRpbWVvdXQgPz8gSU9TX0RFUExPWV9USU1FT1VUX01TfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyci5zdGRlcnIgfHwgZXJyLnN0ZG91dCB8fCBlcnIubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHRpbWVyID0gbmV3IHRpbWluZy5UaW1lcigpLnN0YXJ0KCk7XG4gICAgaWYgKF8udG9Mb3dlcihzdHJhdGVneSkgPT09IEFQUF9JTlNUQUxMX1NUUkFURUdZLklPU19ERVBMT1kpIHtcbiAgICAgIGF3YWl0IGluc3RhbGxXaXRoSW9zRGVwbG95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFmY1NlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEFmY1NlcnZpY2UodGhpcy51ZGlkKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZUlkID0gYXdhaXQgZXh0cmFjdEJ1bmRsZUlkKGFwcCk7XG4gICAgICAgIGNvbnN0IGJ1bmRsZVBhdGhPblBob25lID0gcGF0aC5qb2luKElOU1RBTExBVElPTl9TVEFHSU5HX0RJUiwgYnVuZGxlSWQpO1xuICAgICAgICBhd2FpdCBwdXNoRm9sZGVyKGFmY1NlcnZpY2UsIGFwcCwgYnVuZGxlUGF0aE9uUGhvbmUsIHtcbiAgICAgICAgICB0aW1lb3V0TXM6IHRpbWVvdXQsXG4gICAgICAgICAgZW5hYmxlUGFyYWxsZWxQdXNoOiBfLnRvTG93ZXIoc3RyYXRlZ3kpID09PSBBUFBfSU5TVEFMTF9TVFJBVEVHWS5QQVJBTExFTCxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5zdGFsbE9yVXBncmFkZUFwcGxpY2F0aW9uKGJ1bmRsZVBhdGhPblBob25lLCBhd2FpdCB0aGlzLmlzQXBwSW5zdGFsbGVkKGJ1bmRsZUlkKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLndhcm4oYEVycm9yIGluc3RhbGxpbmcgYXBwICcke2FwcH0nOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQi5UaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICBsb2cud2FybihgQ29uc2lkZXIgaW5jcmVhc2luZyB0aGUgdmFsdWUgb2YgJ2FwcFB1c2hUaW1lb3V0JyBjYXBhYmlsaXR5YCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nLndhcm4oYEZhbGxpbmcgYmFjayB0byAnJHtJT1NfREVQTE9ZfScgdXNhZ2VgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBpbnN0YWxsV2l0aElvc0RlcGxveSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgaW5zdGFsbCAnJHthcHB9JzpcXG5gICtcbiAgICAgICAgICAgIGAgIC0gJHtlcnIubWVzc2FnZX1cXG5gICtcbiAgICAgICAgICAgIGAgIC0gJHtlcnIxLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGFmY1NlcnZpY2UuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmluZm8oYEFwcCBpbnN0YWxsYXRpb24gc3VjY2VlZGVkIGFmdGVyICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc01pbGxpU2Vjb25kcy50b0ZpeGVkKDApfW1zYCk7XG4gIH1cblxuICBhc3luYyBpbnN0YWxsT3JVcGdyYWRlQXBwbGljYXRpb24gKGJ1bmRsZVBhdGhPblBob25lLCBpc1VwZ3JhZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvblNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydE5vdGlmaWNhdGlvblByb3h5U2VydmljZSh0aGlzLnVkaWQpO1xuICAgIGNvbnN0IGluc3RhbGxhdGlvblNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEluc3RhbGxhdGlvblByb3h5U2VydmljZSh0aGlzLnVkaWQpO1xuICAgIGNvbnN0IGFwcEluc3RhbGxlZE5vdGlmaWNhdGlvbiA9IG5ldyBCKChyZXNvbHZlKSA9PiB7XG4gICAgICBub3RpZmljYXRpb25TZXJ2aWNlLm9ic2VydmVOb3RpZmljYXRpb24oQVBQTElDQVRJT05fSU5TVEFMTEVEX05PVElGSUNBVElPTiwge1xuICAgICAgICBub3RpZmljYXRpb246IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGNsaWVudE9wdGlvbnMgPSB7UGFja2FnZVR5cGU6ICdEZXZlbG9wZXInfTtcbiAgICB0cnkge1xuICAgICAgaWYgKGlzVXBncmFkZSkge1xuICAgICAgICBsb2cuZGVidWcoYEFuIHVwZ3JhZGUgb2YgdGhlIGV4aXN0aW5nIGFwcGxpY2F0aW9uIGlzIGdvaW5nIHRvIGJlIHBlcmZvcm1lZGApO1xuICAgICAgICBhd2FpdCBpbnN0YWxsYXRpb25TZXJ2aWNlLnVwZ3JhZGVBcHBsaWNhdGlvbihidW5kbGVQYXRoT25QaG9uZSwgY2xpZW50T3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZGVidWcoYEEgbmV3IGFwcGxpY2F0aW9uIGluc3RhbGxhdGlvbiBpcyBnb2luZyB0byBiZSBwZXJmb3JtZWRgKTtcbiAgICAgICAgYXdhaXQgaW5zdGFsbGF0aW9uU2VydmljZS5pbnN0YWxsQXBwbGljYXRpb24oYnVuZGxlUGF0aE9uUGhvbmUsIGNsaWVudE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYXBwSW5zdGFsbGVkTm90aWZpY2F0aW9uLnRpbWVvdXQoQVBQTElDQVRJT05fTk9USUZJQ0FUSU9OX1RJTUVPVVRfTVMsXG4gICAgICAgICAgYENvdWxkIG5vdCBnZXQgdGhlIGFwcGxpY2F0aW9uIGluc3RhbGxlZCBub3RpZmljYXRpb24gd2l0aGluIGAgK1xuICAgICAgICAgIGAke0FQUExJQ0FUSU9OX05PVElGSUNBVElPTl9USU1FT1VUX01TfW1zIGJ1dCB3ZSB3aWxsIGNvbnRpbnVlYCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy53YXJuKGBGYWlsZWQgdG8gcmVjZWl2ZSB0aGUgbm90aWZpY2F0aW9uLiBFcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGluc3RhbGxhdGlvblNlcnZpY2UuY2xvc2UoKTtcbiAgICAgIG5vdGlmaWNhdGlvblNlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBpbnN0YWxsQXBwICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5zdGFsbCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXBwbGljYXRpb24gb2JqZWN0IGlmIHRlc3QgYXBwIGhhcyAnYnVuZGxlaWQnLlxuICAgKiBUaGUgdGFyZ2V0IGJ1bmRsZWlkIGNhbiBiZSBVc2VyIGFuZCBTeXN0ZW0gYXBwcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkIFRoZSBidW5kbGVJZCB0byBlbnN1cmUgaXQgaXMgaW5zdGFsbGVkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgVHJ1ZSBpZiB0aGUgYnVuZGxlaWQgZXhpc3RzIGluIHRoZSByZXN1bHQgb2YgJ2xpc3RBcHBsaWNhdGlvbnMnIGxpa2U6XG4gICAqIHsgXCJjb20uYXBwbGUuUHJlZmVyZW5jZXNcIjp7XG4gICAqICAgXCJVSVJlcXVpcmVkRGV2aWNlQ2FwYWJpbGl0aWVzXCI6W1wiYXJtNjRcIl0sXG4gICAqICAgXCJVSVJlcXVpcmVzRnVsbFNjcmVlblwiOnRydWUsXG4gICAqICAgXCJDRkJ1bmRsZUluZm9EaWN0aW9uYXJ5VmVyc2lvblwiOlwiNi4wXCIsXG4gICAqICAgXCJFbnRpdGxlbWVudHNcIjpcbiAgICogICAgIHtcImNvbS5hcHBsZS5mcm9udGJvYXJkLmRlbGV0ZS1hcHBsaWNhdGlvbi1zbmFwc2hvdHNcIjp0cnVlLC4uXG4gICAqL1xuICBhc3luYyBpc0FwcEluc3RhbGxlZCAoYnVuZGxlSWQpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgc2VydmljZXMuc3RhcnRJbnN0YWxsYXRpb25Qcm94eVNlcnZpY2UodGhpcy51ZGlkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXBwbGljYXRpb25zID0gYXdhaXQgc2VydmljZS5sb29rdXBBcHBsaWNhdGlvbnMoeyBidW5kbGVJZHM6IGJ1bmRsZUlkIH0pO1xuICAgICAgcmV0dXJuICEhYXBwbGljYXRpb25zW2J1bmRsZUlkXTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2VydmljZS5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHRlcm1pbmF0ZUFwcCAoYnVuZGxlSWQpIHtcbiAgICBsZXQgaW5zdHJ1bWVudFNlcnZpY2U7XG4gICAgbGV0IGluc3RhbGxQcm94eVNlcnZpY2U7XG4gICAgdHJ5IHtcbiAgICAgIGluc3RhbGxQcm94eVNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEluc3RhbGxhdGlvblByb3h5U2VydmljZSh0aGlzLnVkaWQpO1xuICAgICAgY29uc3QgYXBwcyA9IGF3YWl0IGluc3RhbGxQcm94eVNlcnZpY2UubGlzdEFwcGxpY2F0aW9ucygpO1xuICAgICAgaWYgKCFhcHBzW2J1bmRsZUlkXSkge1xuICAgICAgICBsb2cuaW5mbyhgVGhlIGJ1bmRsZSBpZCAnJHtidW5kbGVJZH0nIGRpZCBub3QgZXhpc3RgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhlY3V0YWJsZU5hbWUgPSBhcHBzW2J1bmRsZUlkXS5DRkJ1bmRsZUV4ZWN1dGFibGU7XG4gICAgICBsb2cuZGVidWcoYFRoZSBleGVjdXRhYmxlIG5hbWUgZm9yIHRoZSBidW5kbGUgaWQgJyR7YnVuZGxlSWR9JyB3YXMgJyR7ZXhlY3V0YWJsZU5hbWV9J2ApO1xuICAgICAgaW5zdHJ1bWVudFNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEluc3RydW1lbnRTZXJ2aWNlKHRoaXMudWRpZCk7XG4gICAgICBjb25zdCBwcm9jZXNzZXMgPSBhd2FpdCBpbnN0cnVtZW50U2VydmljZS5jYWxsQ2hhbm5lbChJTlNUUlVNRU5UX0NIQU5ORUwuREVWSUNFX0lORk8sICdydW5uaW5nUHJvY2Vzc2VzJyk7XG4gICAgICBjb25zdCBwcm9jZXNzID0gcHJvY2Vzc2VzLnNlbGVjdG9yLmZpbmQoKHByb2Nlc3MpID0+IHByb2Nlc3MubmFtZSA9PT0gZXhlY3V0YWJsZU5hbWUpO1xuICAgICAgaWYgKCFwcm9jZXNzKSB7XG4gICAgICAgIGxvZy5pbmZvKGBUaGUgcHJvY2VzcyBvZiB0aGUgYnVuZGxlIGlkICcke2J1bmRsZUlkfScgd2FzIG5vdCBydW5uaW5nYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IGluc3RydW1lbnRTZXJ2aWNlLmNhbGxDaGFubmVsKElOU1RSVU1FTlRfQ0hBTk5FTC5QUk9DRVNTX0NPTlRST0wsICdraWxsUGlkOicsIGAke3Byb2Nlc3MucGlkfWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgRmFpbGVkIHRvIGtpbGwgJyR7YnVuZGxlSWR9Jy4gT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLnN0ZGVyciB8fCBlcnIubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGluc3RhbGxQcm94eVNlcnZpY2UpIHtcbiAgICAgICAgaW5zdGFsbFByb3h5U2VydmljZS5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGluc3RydW1lbnRTZXJ2aWNlKSB7XG4gICAgICAgIGluc3RydW1lbnRTZXJ2aWNlLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVOYW1lIFRoZSBuYW1lIG9mIENGQnVuZGxlTmFtZSBpbiBJbmZvLnBsaXN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBBIGxpc3Qgb2YgVXNlciBsZXZlbCBhcHBzJyBidW5kbGUgaWRzIHdoaWNoIGhhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NGQnVuZGxlTmFtZScgYXR0cmlidXRlIGFzICdidW5kbGVOYW1lJy5cbiAgICovXG4gIGFzeW5jIGdldFVzZXJJbnN0YWxsZWRCdW5kbGVJZHNCeUJ1bmRsZU5hbWUgKGJ1bmRsZU5hbWUpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgc2VydmljZXMuc3RhcnRJbnN0YWxsYXRpb25Qcm94eVNlcnZpY2UodGhpcy51ZGlkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXBwbGljYXRpb25zID0gYXdhaXQgc2VydmljZS5saXN0QXBwbGljYXRpb25zKHthcHBsaWNhdGlvblR5cGU6ICdVc2VyJ30pO1xuICAgICAgcmV0dXJuIF8ucmVkdWNlKGFwcGxpY2F0aW9ucywgKGFjYywge0NGQnVuZGxlTmFtZX0sIGtleSkgPT4ge1xuICAgICAgICBpZiAoQ0ZCdW5kbGVOYW1lID09PSBidW5kbGVOYW1lKSB7XG4gICAgICAgICAgYWNjLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgW10pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXJ2aWNlLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0UGxhdGZvcm1WZXJzaW9uICgpIHtcbiAgICByZXR1cm4gYXdhaXQgdXRpbGl0aWVzLmdldE9TVmVyc2lvbih0aGlzLnVkaWQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElPU0RlcGxveTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxrQ0FBa0MsR0FB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
