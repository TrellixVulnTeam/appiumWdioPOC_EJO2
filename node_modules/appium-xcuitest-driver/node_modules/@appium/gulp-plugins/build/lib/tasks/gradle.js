'use strict';

require("source-map-support/register");

const argv = require('yargs').argv;

const replace = require('replace-in-file');

const log = require('fancy-log');

const semver = require('semver');

const globby = require('globby');

function logFileChanges(changes = []) {
  changes = changes.filter(entry => entry.hasChanged).map(entry => entry.file);
  log(`Updated files: ${changes.join(', ')}`);
}

const configure = function configure(gulp) {
  gulp.task('gradle-version-update', async function gradleVersionUpdate() {
    const files = await globby(['app/build.gradle']);

    if (!files.length) {
      throw new Error('No app/build.gradle file found');
    }

    const gradleFile = files[0];
    const version = argv['package-version'];

    if (!version) {
      throw new Error('No package version argument (use `--package-version=xxx`)');
    }

    if (!semver.valid(version)) {
      throw new Error(`Invalid version specified '${version}'. Version should be in the form '1.2.3'`);
    }

    let changedFiles = await replace({
      files: gradleFile,
      from: /^\s*versionName\s+['"](.+)['"]$/gm,
      to: match => {
        log(`Updating gradle build file to version name '${version}'`);
        return match.replace(/\d+\.\d+\.\d+/, version);
      }
    });
    logFileChanges(changedFiles);
    changedFiles = await replace({
      files: gradleFile,
      from: /^\s*versionCode\s+(.+)$/gm,
      to: match => {
        const codeMatch = /\d+/.exec(match.trim());

        if (!codeMatch) {
          throw new Error('Unable to find existing version code');
        }

        const code = parseInt(codeMatch[0], 10) + 1;
        log(`Updating gradle build file to version code '${code}'`);
        return match.replace(/\d+/, code);
      }
    });
    logFileChanges(changedFiles);
  });
};

module.exports = {
  configure
};require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3Rhc2tzL2dyYWRsZS5qcyIsIm5hbWVzIjpbImFyZ3YiLCJyZXF1aXJlIiwicmVwbGFjZSIsImxvZyIsInNlbXZlciIsImdsb2JieSIsImxvZ0ZpbGVDaGFuZ2VzIiwiY2hhbmdlcyIsImZpbHRlciIsImVudHJ5IiwiaGFzQ2hhbmdlZCIsIm1hcCIsImZpbGUiLCJqb2luIiwiY29uZmlndXJlIiwiZ3VscCIsInRhc2siLCJncmFkbGVWZXJzaW9uVXBkYXRlIiwiZmlsZXMiLCJsZW5ndGgiLCJFcnJvciIsImdyYWRsZUZpbGUiLCJ2ZXJzaW9uIiwidmFsaWQiLCJjaGFuZ2VkRmlsZXMiLCJmcm9tIiwidG8iLCJtYXRjaCIsImNvZGVNYXRjaCIsImV4ZWMiLCJ0cmltIiwiY29kZSIsInBhcnNlSW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4iLCJzb3VyY2VzIjpbImxpYi90YXNrcy9ncmFkbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcmd2ID0gcmVxdWlyZSgneWFyZ3MnKS5hcmd2O1xuY29uc3QgcmVwbGFjZSA9IHJlcXVpcmUoJ3JlcGxhY2UtaW4tZmlsZScpO1xuY29uc3QgbG9nID0gcmVxdWlyZSgnZmFuY3ktbG9nJyk7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IGdsb2JieSA9IHJlcXVpcmUoJ2dsb2JieScpO1xuXG5mdW5jdGlvbiBsb2dGaWxlQ2hhbmdlcyhjaGFuZ2VzID0gW10pIHtcbiAgLy8gYGNoYW5nZXNgIHdpbGwgaGF2ZSBlbnRyaWVzIGxpa2VcbiAgLy8gICB7IGZpbGU6IFwiYXBwL2J1aWxkLmdyYWRsZVwiLCBoYXNDaGFuZ2VkOiB0cnVlIH1cbiAgY2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkuaGFzQ2hhbmdlZCkubWFwKChlbnRyeSkgPT4gZW50cnkuZmlsZSk7XG4gIGxvZyhgVXBkYXRlZCBmaWxlczogJHtjaGFuZ2VzLmpvaW4oJywgJyl9YCk7XG59XG5cbmNvbnN0IGNvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZShndWxwKSB7XG4gIGd1bHAudGFzaygnZ3JhZGxlLXZlcnNpb24tdXBkYXRlJywgYXN5bmMgZnVuY3Rpb24gZ3JhZGxlVmVyc2lvblVwZGF0ZSgpIHtcbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IGdsb2JieShbJ2FwcC9idWlsZC5ncmFkbGUnXSk7XG4gICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXBwL2J1aWxkLmdyYWRsZSBmaWxlIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGdyYWRsZUZpbGUgPSBmaWxlc1swXTtcblxuICAgIGNvbnN0IHZlcnNpb24gPSBhcmd2WydwYWNrYWdlLXZlcnNpb24nXTtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGFja2FnZSB2ZXJzaW9uIGFyZ3VtZW50ICh1c2UgYC0tcGFja2FnZS12ZXJzaW9uPXh4eGApJyk7XG4gICAgfVxuICAgIGlmICghc2VtdmVyLnZhbGlkKHZlcnNpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHZlcnNpb24gc3BlY2lmaWVkICcke3ZlcnNpb259Jy4gVmVyc2lvbiBzaG91bGQgYmUgaW4gdGhlIGZvcm0gJzEuMi4zJ2BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGNoYW5nZWRGaWxlcyA9IGF3YWl0IHJlcGxhY2Uoe1xuICAgICAgZmlsZXM6IGdyYWRsZUZpbGUsXG4gICAgICBmcm9tOiAvXlxccyp2ZXJzaW9uTmFtZVxccytbJ1wiXSguKylbJ1wiXSQvZ20sXG4gICAgICB0bzogKG1hdGNoKSA9PiB7XG4gICAgICAgIGxvZyhgVXBkYXRpbmcgZ3JhZGxlIGJ1aWxkIGZpbGUgdG8gdmVyc2lvbiBuYW1lICcke3ZlcnNpb259J2ApO1xuICAgICAgICAvLyBtYXRjaCB3aWxsIGJlIGxpa2UgYHZlcnNpb25OYW1lICcxLjIuMydgXG4gICAgICAgIHJldHVybiBtYXRjaC5yZXBsYWNlKC9cXGQrXFwuXFxkK1xcLlxcZCsvLCB2ZXJzaW9uKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgbG9nRmlsZUNoYW5nZXMoY2hhbmdlZEZpbGVzKTtcblxuICAgIGNoYW5nZWRGaWxlcyA9IGF3YWl0IHJlcGxhY2Uoe1xuICAgICAgZmlsZXM6IGdyYWRsZUZpbGUsXG4gICAgICBmcm9tOiAvXlxccyp2ZXJzaW9uQ29kZVxccysoLispJC9nbSxcbiAgICAgIHRvOiAobWF0Y2gpID0+IHtcbiAgICAgICAgLy8gbWF0Y2ggd2lsbCBiZSBsaWtlIGB2ZXJzaW9uQ29kZSA0MmBcbiAgICAgICAgY29uc3QgY29kZU1hdGNoID0gL1xcZCsvLmV4ZWMobWF0Y2gudHJpbSgpKTtcbiAgICAgICAgaWYgKCFjb2RlTWF0Y2gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGV4aXN0aW5nIHZlcnNpb24gY29kZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXJzZUludChjb2RlTWF0Y2hbMF0sIDEwKSArIDE7XG4gICAgICAgIGxvZyhgVXBkYXRpbmcgZ3JhZGxlIGJ1aWxkIGZpbGUgdG8gdmVyc2lvbiBjb2RlICcke2NvZGV9J2ApO1xuICAgICAgICByZXR1cm4gbWF0Y2gucmVwbGFjZSgvXFxkKy8sIGNvZGUpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICBsb2dGaWxlQ2hhbmdlcyhjaGFuZ2VkRmlsZXMpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25maWd1cmUsXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUVBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE9BQUQsQ0FBUCxDQUFpQkQsSUFBOUI7O0FBQ0EsTUFBTUUsT0FBTyxHQUFHRCxPQUFPLENBQUMsaUJBQUQsQ0FBdkI7O0FBQ0Es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
